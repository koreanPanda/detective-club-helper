<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Detective Club Helper</title>
  <style>
    :root { --pad: 18px; --radius: 16px; --shadow: 0 10px 30px rgba(0,0,0,.08); }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      background: #f6f7fb;
      color: #111;
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }
    .app { width: min(620px, 100%); padding: var(--pad); padding-bottom: calc(var(--pad) + env(safe-area-inset-bottom)); }
    .card { background:#fff; border-radius:var(--radius); box-shadow:var(--shadow); padding:var(--pad); margin:10px 0; }
    h1 { font-size: 22px; margin: 0 0 8px; }
    h2 { font-size: 18px; margin: 0 0 8px; }
    p { margin: 8px 0; line-height: 1.45; color: #333; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    label { font-size: 13px; color: #444; display: block; margin: 12px 0 6px; }
    input, select {
      width: 100%;
      padding: 12px 12px;
      border: 1px solid #d8dbe6;
      border-radius: 12px;
      font-size: 16px;
      outline: none;
      background: #fff;
    }
    input:focus, select:focus { border-color:#7aa7ff; box-shadow:0 0 0 3px rgba(122,167,255,.25); }
    .btn {
      width: 100%;
      padding: 14px 14px;
      border: 0;
      border-radius: 14px;
      font-size: 16px;
      font-weight: 800;
      background: #111;
      color: #fff;
      cursor: pointer;
      margin-top: 12px;
    }
    .btn.secondary { background:#e9ecf6; color:#111; }
    .btn.danger { background:#d62828; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .btn:active { transform: translateY(1px); }
    .muted { color:#666; font-size: 13px; }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius:999px;
      background:#f0f2f9; color:#222; font-size:13px; font-weight:700;
    }
    .divider { height:1px; background:#eef0f6; margin:14px 0; }
    .big { font-size: 22px; font-weight: 900; line-height: 1.25; margin: 6px 0 10px; }
    .center { text-align:center; }
    .progressWrap { height: 10px; background:#eef0f6; border-radius:999px; overflow:hidden; }
    .progressBar { height: 10px; width: 0%; background:#111; transition: width 0.05s linear; }
    .pressArea{
      user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      touch-action: manipulation;
      border:2px dashed #d8dbe6;
      border-radius:18px;
      padding:18px;
      margin-top:12px;
      background:#fbfcff;
    }
    .revealBox{
      border-radius:18px;
      padding:18px;
      background:#111;
      color:#fff;
      margin-top:12px;
      min-height:86px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      font-size:18px;
      font-weight:900;
      opacity:.10;
    }
    table { width:100%; border-collapse:collapse; }
    th, td { padding: 10px 6px; border-bottom: 1px solid #eef0f6; text-align:left; }
    th { font-size: 13px; color:#666; }
    td { font-size: 15px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 420px) { .grid2 { grid-template-columns: 1fr; } }
    .notice{
      font-size: 12px; color:#666; margin-top:10px;
      background:#f5f7ff; border:1px solid #e1e7ff;
      padding:10px 12px; border-radius:12px;
    }

    /* Voting tokens UI */
    .tiles { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px; margin-top:12px; }
    @media (max-width: 420px) { .tiles { grid-template-columns: 1fr; } }
    .tile{
      border:1px solid #e7eaf4;
      border-radius:16px;
      padding:14px;
      background:#fff;
      box-shadow: 0 6px 18px rgba(0,0,0,.05);
      cursor:pointer;
      user-select:none;
      position:relative;
      transition: transform .05s ease;
    }
    .tile:active { transform: translateY(1px); }
    .tileTitle { font-weight:900; font-size:16px; margin:0; }
    .tileSub { font-size:12px; color:#666; margin-top:4px; }
    .tokenStack { display:flex; flex-wrap:wrap; gap:6px; margin-top:10px; }
    .token{
      width: 12px; height: 12px; border-radius:999px; background:#111;
      box-shadow: 0 2px 6px rgba(0,0,0,.2);
    }
    .badge{
      position:absolute; top:10px; right:10px;
      background:#f0f2f9; border:1px solid #e2e6f2;
      padding:6px 8px; border-radius:999px; font-weight:900; font-size:12px;
    }
    .chipRow { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; justify-content:center; }
    .chip{
      background:#f0f2f9; border:1px solid #e2e6f2;
      padding:7px 10px; border-radius:999px; font-size:13px; font-weight:800;
      cursor:pointer;
      user-select:none;
    }
    .chip:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="app" id="app"></div>

<script>
(() => {
  // -----------------------------
  // State
  // -----------------------------
  const STORAGE_KEY = "dc_helper_v2";
  const defaultState = {
    N: 6,
    totalRounds: 0,      // 0 = 무제한
    round: 1,
    phase: "HOME",

    players: [],         // [{id, name, score}]
    // round-specific
    hostId: 1,
    liarId: 2,
    keyword: "",

    revealOrder: [],
    cursor: 0,
    revealed: {},        // {playerId:true}
    // voting
    voteOrder: [],
    voteCursor: 0,
    votes: {},           // {voterId: targetId} (visible log)
    accusations: {},     // {targetId: count}
    _lastAccusationCount: 0,
  };

  let state = load() || initDefault();

  function initDefault() {
    const s = structuredClone(defaultState);
    s.players = [];
    for (let i = 1; i <= s.N; i++) s.players.push({ id: i, name: `Player ${i}`, score: 0 });
    s.hostId = 1;
    s.liarId = Math.min(2, s.N);
    return s;
  }

  function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  function load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch { return null; }
  }

  function resetAll() {
    state = initDefault();
    state.phase = "HOME";
    save();
    render();
  }

  // Back navigation guard (lightweight)
  history.pushState({locked:true}, "");
  window.addEventListener("popstate", () => {
    history.pushState({locked:true}, "");
    toast("뒤로가기는 비활성화되어 있어요. (치팅 방지)");
  });

  // -----------------------------
  // Helpers
  // -----------------------------
  const $app = document.getElementById("app");

  function setPhase(phase) {
    state.phase = phase;
    save();
    render();
  }

  function clampInt(v, min, max, fallback) {
    const n = parseInt(v, 10);
    if (Number.isNaN(n)) return fallback;
    return Math.min(max, Math.max(min, n));
  }

  function playerById(id) { return state.players.find(p => p.id === id); }
  function pname(id) {
    const p = playerById(id);
    return p ? p.name : `${id}번`;
  }
  function pnameWithNo(id) {
    const p = playerById(id);
    return p ? `${p.name} (${id}번)` : `${id}번`;
  }

  function makeOrderExcluding(N, excludeId) {
    const arr = [];
    for (let i=1; i<=N; i++) if (i !== excludeId) arr.push(i);
    return arr;
  }

  function nextHostId(host, N) { return (host % N) + 1; }

  function startRound() {
    state.keyword = (state.keyword || "").trim();
    state.revealOrder = makeOrderExcluding(state.N, state.hostId);
    state.cursor = 0;
    state.revealed = {};
    // voting reset
    state.votes = {};
    state.accusations = {};
    state.voteOrder = [];
    state.voteCursor = 0;
    save();
    setPhase("REVEAL");
  }

  function finishReveal() {
    setPhase("PLAY_START");
  }

  function startVoting() {
    // voting is 공개. host 제외한 사람들만 투표 (룰)
    state.voteOrder = makeOrderExcluding(state.N, state.hostId);
    state.voteCursor = 0;
    state.votes = {};
    state.accusations = {};
    save();
    setPhase("VOTING_TOKENS");
  }

  function registerVote(voterId, targetId) {
    // overwrite allowed: if voter already voted, remove old token then add new.
    const prev = state.votes[voterId];
    if (prev != null) {
      state.accusations[prev] = Math.max(0, (state.accusations[prev] || 0) - 1);
    }
    state.votes[voterId] = targetId;
    state.accusations[targetId] = (state.accusations[targetId] || 0) + 1;
  }

  function applyScoring() {
    const hostId = state.hostId;
    const liarId = state.liarId;

    // accusationCount = number of voters who chose liar
    const accusationCount = state.accusations[liarId] || 0;

    // Everyone who voted liar gets +3 (host doesn't vote by construction)
    for (const voterIdStr of Object.keys(state.votes)) {
      const voterId = parseInt(voterIdStr, 10);
      if (voterId === hostId) continue;
      if (state.votes[voterId] === liarId) {
        const p = playerById(voterId);
        if (p) p.score += 3;
      }
    }

    // If liar got <= 1 accusation: liar +5, host +4
    if (accusationCount <= 1) {
      const liar = playerById(liarId);
      const host = playerById(hostId);
      if (liar) liar.score += 5;
      if (host) host.score += 4;
    }

    state._lastAccusationCount = accusationCount;
    save();
  }

  function finishVoting() {
    applyScoring();
    setPhase("RESULT");
  }

  function nextRound() {
    state.round += 1;
    state.hostId = nextHostId(state.hostId, state.N);
    state.keyword = "";
    // reset round vars
    state.revealOrder = [];
    state.cursor = 0;
    state.revealed = {};
    state.votes = {};
    state.accusations = {};
    state.voteOrder = [];
    state.voteCursor = 0;
    save();
    setPhase("ROUND_SETUP");
  }

  function ensurePlayersForN(newN) {
    // Keep existing names/scores if possible
    const prev = new Map(state.players.map(p => [p.id, p]));
    const next = [];
    for (let i=1;i<=newN;i++) {
      const old = prev.get(i);
      next.push({
        id: i,
        name: old?.name ?? `Player ${i}`,
        score: old?.score ?? 0
      });
    }
    state.players = next;
    state.N = newN;
    // clamp host/liar
    if (state.hostId > newN) state.hostId = 1;
    if (state.liarId > newN) state.liarId = Math.min(2, newN);
    if (state.liarId === state.hostId) state.liarId = (state.hostId % newN) + 1;
  }

  // Tiny toast
  let toastTimer = null;
  function toast(msg) {
    const id = "toast";
    let el = document.getElementById(id);
    if (!el) {
      el = document.createElement("div");
      el.id = id;
      el.style.position = "fixed";
      el.style.left = "50%";
      el.style.bottom = "20px";
      el.style.transform = "translateX(-50%)";
      el.style.background = "rgba(17,17,17,.92)";
      el.style.color = "#fff";
      el.style.padding = "10px 12px";
      el.style.borderRadius = "12px";
      el.style.fontSize = "13px";
      el.style.zIndex = "9999";
      document.body.appendChild(el);
    }
    el.textContent = msg;
    el.style.display = "block";
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { el.style.display = "none"; }, 1600);
  }

  // -----------------------------
  // Long press logic (2s) -> reveal stays (no need to hide again)
  // -----------------------------
  function attachLongPressOnce(container, onCompleted) {
    let holding = false;
    let startedAt = 0;
    let raf = null;
    let completed = false;

    const bar = container.querySelector(".progressBar");

    const update = () => {
      if (!holding) return;
      const elapsed = performance.now() - startedAt;
      const p = Math.min(1, elapsed / 2000);
      bar.style.width = (p * 100).toFixed(1) + "%";

      if (p >= 1 && !completed) {
        completed = true;
        holding = false;
        if (raf) cancelAnimationFrame(raf);
        onCompleted();
      } else {
        raf = requestAnimationFrame(update);
      }
    };

    const start = (e) => {
      e.preventDefault();
      if (completed) return;
      if (holding) return;
      holding = true;
      bar.style.width = "0%";
      startedAt = performance.now();
      raf = requestAnimationFrame(update);
    };

    const end = (e) => {
      e.preventDefault();
      if (!holding) return;
      holding = false;
      if (raf) cancelAnimationFrame(raf);
      // keep progress where it stopped; user can try again
    };

    container.addEventListener("pointerdown", start, {passive:false});
    container.addEventListener("pointerup", end, {passive:false});
    container.addEventListener("pointercancel", end, {passive:false});
    container.addEventListener("pointerleave", end, {passive:false});
  }

  // -----------------------------
  // Render
  // -----------------------------
  function render() {
    switch (state.phase) {
      case "HOME": return renderHome();
      case "ROUND_SETUP": return renderRoundSetup();
      case "REVEAL": return renderReveal();
      case "PASS_NEXT": return renderPassNext();
      case "PLAY_START": return renderPlayStart();
      case "VOTING_TOKENS": return renderVotingTokens();
      case "RESULT": return renderResult();
      default:
        state.phase = "HOME"; save(); return renderHome();
    }
  }

  function renderHome() {
    $app.innerHTML = `
      <div class="card">
        <h1>Detective Club Helper</h1>
        <p class="muted">한 대의 폰으로 제시어/라이어 분배 + 공개 지목(토큰) + 자동 점수</p>
        <div class="divider"></div>

        <div class="grid2">
          <div>
            <label>참가자 수 (N)</label>
            <input id="N" inputmode="numeric" value="${state.N}" />
          </div>
          <div>
            <label>총 라운드 수 (0 = 무제한)</label>
            <input id="R" inputmode="numeric" value="${state.totalRounds}" />
          </div>
        </div>

        <label>플레이어 이름</label>
        <div id="nameList"></div>

        <button class="btn" id="start">설정 완료 → 라운드 1</button>
        <button class="btn secondary" id="reset">전체 초기화</button>

        <div class="notice">
          iPhone에서는 화면 잠금이 걸리면 흐름이 끊길 수 있어요. 게임 중에는 자동 잠금을 꺼두면 편합니다.
        </div>
      </div>
      ${renderScoreTableCard()}
    `;

    const nameList = document.getElementById("nameList");

    function renderNameInputs(n) {
      let html = "";
      for (let i=1;i<=n;i++) {
        const p = state.players.find(x => x.id === i);
        html += `
          <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
            <div class="pill" style="min-width:72px; justify-content:center;">${i}번</div>
            <input data-pid="${i}" value="${escapeHtml(p?.name ?? `Player ${i}`)}" placeholder="이름" />
          </div>
        `;
      }
      nameList.innerHTML = html;

      nameList.querySelectorAll("input[data-pid]").forEach(inp => {
        inp.addEventListener("input", (e) => {
          const id = parseInt(e.target.getAttribute("data-pid"), 10);
          const p = state.players.find(x => x.id === id);
          if (p) p.name = e.target.value;
          save();
        });
      });
    }

    renderNameInputs(state.N);

    document.getElementById("N").addEventListener("input", (e) => {
      const n = clampInt(e.target.value, 3, 20, state.N);
      ensurePlayersForN(n);
      save();
      renderNameInputs(n);
      // rerender score card too
      document.querySelectorAll(".card")[1].outerHTML = renderScoreTableCard();
    });

    document.getElementById("start").onclick = () => {
      const N = clampInt(document.getElementById("N").value, 3, 20, state.N);
      const R = clampInt(document.getElementById("R").value, 0, 50, 0);
      ensurePlayersForN(N);

      state.totalRounds = R;
      state.round = 1;
      state.hostId = 1;
      state.liarId = Math.min(2, state.N);
      if (state.liarId === state.hostId) state.liarId = (state.hostId % state.N) + 1;

      // reset scores (new game)
      state.players = state.players.map(p => ({...p, score: 0, name: (p.name||"").trim() || `Player ${p.id}`}));
      state.keyword = "";
      save();
      setPhase("ROUND_SETUP");
    };

    document.getElementById("reset").onclick = () => {
      if (confirm("정말 초기화할까요? 점수와 설정이 모두 리셋됩니다.")) resetAll();
    };
  }

  function renderRoundSetup() {
    const hostOptions = state.players.map(p =>
      `<option value="${p.id}" ${p.id===state.hostId?'selected':''}>${escapeHtml(p.name)} (${p.id}번)</option>`
    ).join("");

    const liarOptions = state.players
      .filter(p => p.id !== state.hostId)
      .map(p => `<option value="${p.id}" ${p.id===state.liarId?'selected':''}>${escapeHtml(p.name)} (${p.id}번)</option>`)
      .join("");

    $app.innerHTML = `
      <div class="card">
        <div class="row">
          <h1>라운드 ${state.round}</h1>
          <span class="pill">제시자: ${escapeHtml(pnameWithNo(state.hostId))}</span>
        </div>
        <p class="muted">제시자가 제시어와 라이어를 설정합니다.</p>

        <label>제시자</label>
        <select id="host">${hostOptions}</select>

        <label>라이어</label>
        <select id="liar">${liarOptions}</select>

        <label>제시어 (텍스트 1줄)</label>
        <input id="keyword" placeholder="예) 우주, 커피, 비 오는 날..." value="${escapeHtml(state.keyword||"")}" />

        <button class="btn" id="go">제시어 분배(리빌) 시작</button>
        <button class="btn secondary" id="score">점수표 보기</button>
        <button class="btn secondary" id="home">홈으로</button>

        <div class="notice">
          리빌 시작 후에는 라이어 정보가 다시 노출되지 않도록 뒤로가기를 막아두었습니다.
        </div>
      </div>
      ${renderScoreTableCard()}
    `;

    document.getElementById("host").onchange = (e) => {
      state.hostId = clampInt(e.target.value, 1, state.N, 1);
      if (state.liarId === state.hostId) state.liarId = (state.hostId % state.N) + 1;
      save();
      render();
    };

    document.getElementById("liar").onchange = (e) => {
      state.liarId = clampInt(e.target.value, 1, state.N, 2);
      if (state.liarId === state.hostId) {
        toast("제시자와 라이어가 같을 수는 없어요.");
        state.liarId = (state.hostId % state.N) + 1;
      }
      save();
      render();
    };

    document.getElementById("go").onclick = () => {
      const keyword = document.getElementById("keyword").value.trim();
      if (!keyword) { toast("제시어를 입력해 주세요."); return; }
      if (state.liarId === state.hostId) { toast("라이어는 제시자가 될 수 없어요."); return; }
      state.keyword = keyword;
      save();
      startRound();
    };

    document.getElementById("home").onclick = () => setPhase("HOME");
    document.getElementById("score").onclick = () => toast("아래 점수표를 확인하세요.");
  }

  function renderReveal() {
    const order = state.revealOrder || [];
    const total = order.length; // N-1
    if (state.cursor >= total) { finishReveal(); return; }

    const currentId = order[state.cursor];
    const currentName = pnameWithNo(currentId);

    const already = !!state.revealed?.[currentId];
    const isLiar = currentId === state.liarId;
    const secretText = isLiar
      ? "당신은 라이어입니다. 제시어를 유추해보세요."
      : `제시어는 “${state.keyword}” 입니다.`;

    $app.innerHTML = `
      <div class="card">
        <div class="row">
          <h1>제시어 확인</h1>
          <span class="pill">${state.cursor+1} / ${total}</span>
        </div>

        <p class="big center">${escapeHtml(currentName)} 차례</p>

        <div class="pressArea" id="pressArea">
          <p class="center pressHint">${already ? "이미 확인했습니다." : "2초간 꾹 눌러 공개하세요."}</p>
          <div class="progressWrap"><div class="progressBar"></div></div>

          <div class="revealBox" id="revealBox">${already ? escapeHtml(secretText) : "(여기에 표시)"}</div>
        </div>

        <button class="btn" id="confirm" ${already ? "" : "disabled"}>다음 참가자에게 넘기기</button>
        <button class="btn secondary" id="abort">라운드 설정으로 (리셋)</button>
      </div>
    `;

    const revealBox = document.getElementById("revealBox");
    const confirmBtn = document.getElementById("confirm");

    if (!already) {
      attachLongPressOnce(document.getElementById("pressArea"), () => {
        // 2초 달성 -> reveal stays
        state.revealed[currentId] = true;
        save();
        revealBox.style.opacity = "1";
        revealBox.textContent = secretText;
        confirmBtn.disabled = false;
        toast("확인 완료!");
      });
    } else {
      revealBox.style.opacity = "1";
      confirmBtn.disabled = false;
    }

    confirmBtn.onclick = () => {
      if (!state.revealed[currentId]) { toast("먼저 2초간 눌러 확인해 주세요."); return; }
      setPhase("PASS_NEXT");
    };

    document.getElementById("abort").onclick = () => {
      if (confirm("리빌을 중단하고 라운드 설정으로 돌아갈까요? (이번 라운드 진행은 초기화됩니다)")) {
        state.revealOrder = [];
        state.cursor = 0;
        state.revealed = {};
        state.votes = {};
        state.accusations = {};
        save();
        setPhase("ROUND_SETUP");
      }
    };
  }

  function renderPassNext() {
    const order = state.revealOrder || [];
    const total = order.length;
    const currentId = order[state.cursor];

    $app.innerHTML = `
      <div class="card">
        <h1 class="center">다음 사람에게 넘기기</h1>
        <p class="center">이 화면 그대로 <b>다음 사용자에게 휴대폰을 넘겨주세요.</b></p>
        <p class="muted center">방금 확인: ${escapeHtml(pnameWithNo(currentId))} · 진행: ${state.cursor+1}/${total}</p>

        <button class="btn" id="next">다음 참가자 시작</button>
        <button class="btn secondary" id="back">이전 화면</button>
      </div>
    `;

    document.getElementById("next").onclick = () => {
      state.cursor += 1;
      save();
      setPhase("REVEAL");
    };
    document.getElementById("back").onclick = () => setPhase("REVEAL");
  }

  function renderPlayStart() {
    $app.innerHTML = `
      <div class="card">
        <h1 class="center">게임을 시작합니다!</h1>
        <p class="center">
          오프라인에서 카드 2장씩 내려놓은 뒤,<br/>
          <b>라이어 지목</b>을 진행하세요.
        </p>

        <button class="btn" id="vote">라이어 지목 시작 (토큰)</button>
        <button class="btn secondary" id="setup">라운드 설정으로</button>
      </div>
      ${renderScoreTableCard()}
    `;

    document.getElementById("vote").onclick = () => startVoting();
    document.getElementById("setup").onclick = () => setPhase("ROUND_SETUP");
  }

  function renderVotingTokens() {
    const voters = state.voteOrder || [];
    const targets = state.players
      .filter(p => p.id !== state.hostId) // 제시자 제외(선택지에서도 제외)
      .map(p => p.id);

    if (state.voteCursor >= voters.length) {
      finishVoting();
      return;
    }

    const currentVoterId = voters[state.voteCursor];
    const currentVoterName = pnameWithNo(currentVoterId);

    const accusationCount = (id) => state.accusations?.[id] || 0;

    const tilesHtml = targets.map(tid => {
      const count = accusationCount(tid);
      const tokens = Array.from({length: Math.min(count, 12)}, () => `<span class="token"></span>`).join("");
      const more = count > 12 ? `<span class="muted" style="font-weight:900;">+${count-12}</span>` : "";
      return `
        <div class="tile" data-target="${tid}">
          <div class="badge">${count}</div>
          <div class="tileTitle">${escapeHtml(pname(tid))}</div>
          <div class="tileSub">${tid}번</div>
          <div class="tokenStack">${tokens}${more}</div>
        </div>
      `;
    }).join("");

    // 공개 로그(선택): 누가 누구 찍었는지 칩으로 보이게
    const chips = Object.entries(state.votes)
      .map(([voterStr, targetId]) => {
        const v = parseInt(voterStr, 10);
        return `<span class="chip">${escapeHtml(pname(v))} → ${escapeHtml(pname(targetId))}</span>`;
      }).join("");

    $app.innerHTML = `
      <div class="card">
        <div class="row">
          <h1>라이어 지목 (공개)</h1>
          <span class="pill">${state.voteCursor+1} / ${voters.length}</span>
        </div>

        <p class="big center">지금 차례: ${escapeHtml(currentVoterName)}</p>
        <p class="center muted">아래에서 라이어라고 생각하는 사람을 <b>한 번 탭</b>하세요.</p>

        <div class="tiles">${tilesHtml}</div>

        <div class="divider"></div>
        <p class="muted center">현재 지목 기록</p>
        <div class="chipRow">${chips || `<span class="muted">아직 없음</span>`}</div>

        <button class="btn secondary" id="undo">이번 차례 되돌리기</button>
        <button class="btn secondary" id="cancel">취소(라운드로)</button>

        <div class="notice">
          제시자(${escapeHtml(pnameWithNo(state.hostId))})는 지목 대상에서 제외됩니다.
        </div>
      </div>
    `;

    // Click target tile
    document.querySelectorAll(".tile[data-target]").forEach(tile => {
      tile.addEventListener("click", () => {
        const targetId = parseInt(tile.getAttribute("data-target"), 10);
        // Register vote for current voter
        registerVote(currentVoterId, targetId);
        // Advance to next voter
        state.voteCursor += 1;
        save();
        render();
      });
    });

    document.getElementById("undo").onclick = () => {
      if (state.voteCursor <= 0) { toast("되돌릴 차례가 없어요."); return; }
      // Step back one voter, remove their vote
      const prevVoterId = voters[state.voteCursor - 1];
      const prevTarget = state.votes[prevVoterId];
      if (prevTarget != null) {
        state.accusations[prevTarget] = Math.max(0, (state.accusations[prevTarget] || 0) - 1);
        delete state.votes[prevVoterId];
      }
      state.voteCursor -= 1;
      save();
      toast("한 차례 되돌렸어요.");
      render();
    };

    document.getElementById("cancel").onclick = () => {
      if (confirm("지목을 취소하고 라운드 화면으로 돌아갈까요? (입력된 지목은 초기화됩니다)")) {
        state.votes = {};
        state.accusations = {};
        state.voteOrder = [];
        state.voteCursor = 0;
        save();
        setPhase("ROUND_SETUP");
      }
    };
  }

  function renderResult() {
    const acc = state._lastAccusationCount ?? 0;
    const bonusApplied = acc <= 1;

    $app.innerHTML = `
      <div class="card">
        <h1>라운드 ${state.round} 결과</h1>

        <p><b>라이어:</b> ${escapeHtml(pnameWithNo(state.liarId))}</p>
        <p><b>제시자:</b> ${escapeHtml(pnameWithNo(state.hostId))}</p>
        <p><b>라이어 지목 수:</b> ${acc}명</p>
        <p><b>보너스:</b> ${bonusApplied ? "적용 (라이어 +5, 제시자 +4)" : "미적용"}</p>

        <div class="divider"></div>
        <h2>점수표</h2>
        ${renderScoreTable()}

        <button class="btn" id="nextRound">다음 라운드</button>
        <button class="btn secondary" id="setup">라운드 설정으로</button>
        <button class="btn danger" id="reset">게임 초기화</button>

        ${renderGameEndHint()}
      </div>
    `;

    document.getElementById("nextRound").onclick = () => {
      if (state.totalRounds > 0 && state.round >= state.totalRounds) {
        toast("설정한 총 라운드 수에 도달했습니다. (홈에서 변경 가능)");
        setPhase("HOME");
        return;
      }
      nextRound();
    };

    document.getElementById("setup").onclick = () => setPhase("ROUND_SETUP");
    document.getElementById("reset").onclick = () => {
      if (confirm("정말 초기화할까요?")) resetAll();
    };
  }

  function renderScoreTable() {
    let rows = "";
    for (let i=1;i<=state.N;i++) {
      const p = playerById(i);
      rows += `<tr><td>${escapeHtml(p?.name ?? `Player ${i}`)} <span class="muted">(${i}번)</span></td><td>${p?.score ?? 0}</td></tr>`;
    }
    return `
      <table>
        <thead><tr><th>플레이어</th><th>점수</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function renderScoreTableCard() {
    return `
      <div class="card">
        <h2>점수표</h2>
        ${renderScoreTable()}
      </div>
    `;
  }

  function renderGameEndHint() {
    if (state.totalRounds > 0) {
      return `<p class="muted">총 라운드 수: ${state.totalRounds} · 현재: ${state.round}</p>`;
    }
    return `<p class="muted">총 라운드 수: 무제한</p>`;
  }

  function escapeHtml(str) {
    return (str ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");
  }

  // Boot
  render();

})();
</script>
</body>
</html>
