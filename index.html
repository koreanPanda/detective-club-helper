<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Detective Club Helper</title>
  <style>
    :root { --pad: 18px; --radius: 16px; --shadow: 0 10px 30px rgba(0,0,0,.08); }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      background: #f6f7fb;
      color: #111;
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }
    .app { width: min(620px, 100%); padding: var(--pad); padding-bottom: calc(var(--pad) + env(safe-area-inset-bottom)); }
    .card { background:#fff; border-radius:var(--radius); box-shadow:var(--shadow); padding:var(--pad); margin:10px 0; }
    h1 { font-size: 22px; margin: 0 0 8px; }
    h2 { font-size: 18px; margin: 0 0 8px; }
    p { margin: 8px 0; line-height: 1.45; color: #333; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    label { font-size: 13px; color: #444; display: block; margin: 12px 0 6px; }
    input, select {
      width: 100%;
      padding: 12px 12px;
      border: 1px solid #d8dbe6;
      border-radius: 12px;
      font-size: 16px;
      outline: none;
      background: #fff;
      color:#111;
    }
    input:focus, select:focus { border-color:#7aa7ff; box-shadow:0 0 0 3px rgba(122,167,255,.25); }
    .btn {
      width: 100%;
      padding: 14px 14px;
      border: 0;
      border-radius: 14px;
      font-size: 16px;
      font-weight: 800;
      background: #111;
      color: #fff;
      cursor: pointer;
      margin-top: 12px;
    }
    .btn.secondary { background:#e9ecf6; color:#111; }
    .btn.danger { background:#d62828; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .btn:active { transform: translateY(1px); }
    .muted { color:#666; font-size: 13px; }
    .pill {
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius:999px;
      background:#f0f2f9; color:#222; font-size:13px; font-weight:700;
    }
    .divider { height:1px; background:#eef0f6; margin:14px 0; }
    .big { font-size: 22px; font-weight: 900; line-height: 1.25; margin: 6px 0 10px; }
    .center { text-align:center; }
    .progressWrap { height: 10px; background:#eef0f6; border-radius:999px; overflow:hidden; }
    .progressBar { height: 10px; width: 0%; background:#111; transition: width 0.05s linear; }
    .pressArea{
      user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      touch-action: manipulation;
      border:2px dashed #d8dbe6;
      border-radius:18px;
      padding:18px;
      margin-top:12px;
      background:#fbfcff;
    }
    .revealBox{
      border-radius:18px;
      padding:18px;
      background:#111;
      color:#fff;
      margin-top:12px;
      min-height:86px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      font-size:18px;
      font-weight:900;
      opacity:.10;
    }
    table { width:100%; border-collapse:collapse; }
    th, td { padding: 10px 6px; border-bottom: 1px solid #eef0f6; text-align:left; }
    th { font-size: 13px; color:#666; }
    td { font-size: 15px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 420px) { .grid2 { grid-template-columns: 1fr; } }
    .notice{
      font-size: 12px; color:#666; margin-top:10px;
      background:#f5f7ff; border:1px solid #e1e7ff;
      padding:10px 12px; border-radius:12px;
    }

    /* Player highlight */
    .pmark{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 4px 10px;
      border-radius: 999px;
      font-weight: 900;
      color:#111;
      background: var(--bg, #f0f2f9);
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 6px 18px rgba(0,0,0,.06);
      white-space: nowrap;
    }
    .dot{
      width: 10px; height: 10px; border-radius:999px;
      background: var(--c, #111);
      box-shadow: 0 2px 6px rgba(0,0,0,.12);
      flex: 0 0 auto;
    }
    .pno { font-weight: 800; color:#333; opacity:.75; font-size: 12px; }

    /* Name entry: placeholder-like default that clears on first focus */
    .nameInput.defaultName {
      color: #9aa0ad;
      font-weight: 700;
    }
    .nameInput.realName {
      color: #111;
      font-weight: 800;
    }

    /* Colored small token for "1번" etc in name list */
    .numToken{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:72px;
      height: 40px;
      padding: 0 12px;
      border-radius: 999px;
      font-weight: 900;
      border: 1px solid rgba(0,0,0,.06);
      box-shadow: 0 6px 18px rgba(0,0,0,.06);
      background: var(--bg, #f0f2f9);
      color:#111;
      gap:8px;
    }
    .numToken .dot{
      width: 10px; height: 10px; border-radius:999px;
      background: var(--c, #111);
      box-shadow: 0 2px 6px rgba(0,0,0,.12);
    }

    /* Voting tokens UI */
    .tiles { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px; margin-top:12px; }
    @media (max-width: 420px) { .tiles { grid-template-columns: 1fr; } }
    .tile{
      border:1px solid #e7eaf4;
      border-radius:16px;
      padding:14px;
      background:#fff;
      box-shadow: 0 6px 18px rgba(0,0,0,.05);
      cursor:pointer;
      user-select:none;
      position:relative;
    }
    .tileTitle { font-weight:900; font-size:16px; margin:0; }
    .tileSub { font-size:12px; color:#666; margin-top:4px; }
    .tokenStack { display:flex; flex-wrap:wrap; gap:6px; margin-top:10px; align-items:center; }
    .token{
      width: 12px; height: 12px; border-radius:999px;
      background: var(--c, #111);
      box-shadow: 0 2px 6px rgba(0,0,0,.18);
    }
    .badge{
      position:absolute; top:10px; right:10px;
      background:#f0f2f9; border:1px solid #e2e6f2;
      padding:6px 8px; border-radius:999px; font-weight:900; font-size:12px;
    }
    .chipRow { display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; justify-content:center; }
    .chip{
      background:#f0f2f9; border:1px solid #e2e6f2;
      padding:7px 10px; border-radius:999px; font-size:13px; font-weight:800;
      cursor:pointer;
      user-select:none;
    }

    /* Disabled target tile */
    .tile.disabled{
      opacity: .45;
      cursor: not-allowed;
      box-shadow: none;
    }

    /* Hold-to-vote bar (0.5s) */
    .tileHoldBarWrap{
      height: 8px;
      background:#eef0f6;
      border-radius:999px;
      overflow:hidden;
      margin-top:10px;
    }
    .tileHoldBar{
      height: 8px;
      width: 0%;
      background:#111;
      transition: width 0.05s linear;
    }
    .tileHoldHint{
      font-size: 12px;
      color:#666;
      margin-top:8px;
      text-align:center;
    }

    /* Wobble + Pop for vote tiles */
    @keyframes wobble {
      0%   { transform: translateX(0) rotate(0deg); }
      15%  { transform: translateX(-1px) rotate(-0.6deg); }
      30%  { transform: translateX(1px) rotate(0.6deg); }
      45%  { transform: translateX(-1px) rotate(-0.6deg); }
      60%  { transform: translateX(1px) rotate(0.6deg); }
      75%  { transform: translateX(-0.5px) rotate(-0.3deg); }
      100% { transform: translateX(0) rotate(0deg); }
    }
    @keyframes pop {
      0%   { transform: scale(1); }
      50%  { transform: scale(0.97); }
      100% { transform: scale(1.02); }
    }
    .tile.wobbling{
      animation: wobble 140ms linear infinite;
      border-color: rgba(0,0,0,.20);
      box-shadow: 0 10px 24px rgba(0,0,0,.12);
    }
    .tile.popping{
      animation: pop 120ms ease-out 1;
    }
  </style>
</head>
<body>
  <div class="app" id="app"></div>

<script>
(() => {
  const STORAGE_KEY = "dc_helper_v6_names";

  const PASTELS = [
    "#FFD6A5", "#FDFFB6", "#CAFFBF", "#9BF6FF", "#A0C4FF",
    "#BDB2FF", "#FFC6FF", "#FFADAD", "#CDEAC0", "#B9FBC0",
    "#D0F4DE", "#FDE2E4", "#E2F0CB", "#CFBAF0", "#F1C0E8",
    "#F9F9C5", "#BEE1E6", "#EAC4D5", "#C6DEF1", "#F2C6DE"
  ];

  const defaultState = {
    N: 6,
    totalRounds: 0,
    round: 1,
    phase: "HOME",
    players: [],         // {id, name, score, color, isDefaultName}
    hostId: 1,
    liarId: null,
    keyword: "",
    revealOrder: [],
    cursor: 0,
    revealed: {},
    voteOrder: [],
    voteCursor: 0,
    votes: {},
    accusations: {},
    _lastAccusationCount: 0,
  };

  let state = load() || initDefault();

  function initDefault() {
    const s = structuredClone(defaultState);
    s.players = [];
    for (let i = 1; i <= s.N; i++) {
      s.players.push({
        id: i,
        name: `Player ${i}`,
        score: 0,
        color: colorForId(i),
        isDefaultName: true
      });
    }
    s.hostId = 1;
    return s;
  }

  function save() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
  function load() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const obj = JSON.parse(raw);

      // Backfill
      if (obj?.players?.length) {
        obj.players = obj.players.map(p => ({
          ...p,
          color: p.color || colorForId(p.id),
          isDefaultName: (typeof p.isDefaultName === "boolean") ? p.isDefaultName : isLooksLikeDefault(p.name, p.id),
        }));
      }
      return obj;
    } catch { return null; }
  }

  function resetAll() {
    state = initDefault();
    state.phase = "HOME";
    save();
    render();
  }

  // back navigation guard
  history.pushState({locked:true}, "");
  window.addEventListener("popstate", () => {
    history.pushState({locked:true}, "");
    toast("뒤로가기는 비활성화되어 있어요. (치팅 방지)");
  });

  const $app = document.getElementById("app");

  function setPhase(phase) { state.phase = phase; save(); render(); }

  function clampInt(v, min, max, fallback) {
    const n = parseInt(v, 10);
    if (Number.isNaN(n)) return fallback;
    return Math.min(max, Math.max(min, n));
  }

  function colorForId(id) { return PASTELS[(id - 1) % PASTELS.length]; }

  function hexToRgba(hex, a) {
    const h = (hex || "").replace("#", "");
    const v = h.length === 3 ? h.split("").map(ch => ch + ch).join("") : h;
    const r = parseInt(v.slice(0,2), 16);
    const g = parseInt(v.slice(2,4), 16);
    const b = parseInt(v.slice(4,6), 16);
    return `rgba(${r}, ${g}, ${b}, ${a})`;
  }

  function playerById(id) { return state.players.find(p => p.id === id); }
  function pcolor(id) { return playerById(id)?.color || colorForId(id); }

  function pmarkHTML(id, withNo=true) {
    const p = playerById(id);
    const name = p?.name ?? `${id}번`;
    const c = pcolor(id);
    const bg = hexToRgba(c, 0.28);
    return `
      <span class="pmark" style="--c:${c};--bg:${bg}">
        <span class="dot" style="--c:${c}"></span>
        <span>${escapeHtml(name)}</span>
        ${withNo ? `<span class="pno">${id}번</span>` : ``}
      </span>
    `;
  }

  function numTokenHTML(id) {
    const c = pcolor(id);
    const bg = hexToRgba(c, 0.28);
    return `
      <div class="numToken" style="--c:${c};--bg:${bg}">
        <span class="dot" style="--c:${c}"></span>
        <span>${id}번</span>
      </div>
    `;
  }

  function makeOrderExcluding(N, excludeId) {
    const arr = [];
    for (let i=1; i<=N; i++) if (i !== excludeId) arr.push(i);
    return arr;
  }
  function nextHostId(host, N) { return (host % N) + 1; }
  function pickRandom(arr) { return arr?.length ? arr[Math.floor(Math.random() * arr.length)] : null; }

  function startRound() {
    state.keyword = (state.keyword || "").trim();
    state.revealOrder = makeOrderExcluding(state.N, state.hostId);
    state.cursor = 0;
    state.revealed = {};
    state.votes = {};
    state.accusations = {};
    state.voteOrder = [];
    state.voteCursor = 0;

    state.liarId = pickRandom(state.revealOrder);

    save();
    setPhase("REVEAL");
  }

  function finishReveal() { setPhase("PLAY_START"); }

  function startVoting() {
    state.voteOrder = makeOrderExcluding(state.N, state.hostId);
    state.voteCursor = 0;
    state.votes = {};
    state.accusations = {};
    save();
    setPhase("VOTING_TOKENS");
  }

  function rebuildAccusationsFromVotes() {
    const acc = {};
    for (const [voterStr, targetId] of Object.entries(state.votes)) {
      const tid = parseInt(targetId, 10);
      acc[tid] = (acc[tid] || 0) + 1;
    }
    state.accusations = acc;
  }

  function registerVote(voterId, targetId) {
    state.votes[voterId] = targetId;
    rebuildAccusationsFromVotes();
  }

  function applyScoring() {
    const hostId = state.hostId;
    const liarId = state.liarId;
    const accusationCount = state.accusations[liarId] || 0;

    for (const voterIdStr of Object.keys(state.votes)) {
      const voterId = parseInt(voterIdStr, 10);
      if (voterId === hostId) continue;
      if (parseInt(state.votes[voterId], 10) === liarId) {
        const p = playerById(voterId);
        if (p) p.score += 3;
      }
    }

    if (accusationCount <= 1) {
      const liar = playerById(liarId);
      const host = playerById(hostId);
      if (liar) liar.score += 5;
      if (host) host.score += 4;
    }

    state._lastAccusationCount = accusationCount;
    save();
  }

  function finishVoting() {
    applyScoring();
    setPhase("RESULT");
  }

  function nextRound() {
    state.round += 1;
    state.hostId = nextHostId(state.hostId, state.N);
    state.keyword = "";
    state.liarId = null;

    state.revealOrder = [];
    state.cursor = 0;
    state.revealed = {};
    state.votes = {};
    state.accusations = {};
    state.voteOrder = [];
    state.voteCursor = 0;
    save();
    setPhase("ROUND_SETUP");
  }

  function ensurePlayersForN(newN) {
    const prev = new Map(state.players.map(p => [p.id, p]));
    const next = [];
    for (let i=1;i<=newN;i++) {
      const old = prev.get(i);
      const name = old?.name ?? `Player ${i}`;
      const isDef = (typeof old?.isDefaultName === "boolean") ? old.isDefaultName : isLooksLikeDefault(name, i);
      next.push({
        id: i,
        name,
        score: old?.score ?? 0,
        color: old?.color ?? colorForId(i),
        isDefaultName: isDef
      });
    }
    state.players = next;
    state.N = newN;
    if (state.hostId > newN) state.hostId = 1;
  }

  function isLooksLikeDefault(name, id) {
    return (name || "").trim() === `Player ${id}`;
  }

  // Toast
  let toastTimer = null;
  function toast(msg) {
    const id = "toast";
    let el = document.getElementById(id);
    if (!el) {
      el = document.createElement("div");
      el.id = id;
      el.style.position = "fixed";
      el.style.left = "50%";
      el.style.bottom = "20px";
      el.style.transform = "translateX(-50%)";
      el.style.background = "rgba(17,17,17,.92)";
      el.style.color = "#fff";
      el.style.padding = "10px 12px";
      el.style.borderRadius = "12px";
      el.style.fontSize = "13px";
      el.style.zIndex = "9999";
      document.body.appendChild(el);
    }
    el.textContent = msg;
    el.style.display = "block";
    clearTimeout(toastTimer);
    toastTimer = setTimeout(() => { el.style.display = "none"; }, 1600);
  }

  function hapticTick(ms = 18) {
    try {
      if (navigator.vibrate) navigator.vibrate(ms);
    } catch {}
  }

  // Reveal long press (2s)
  function attachLongPressOnce(container, onCompleted) {
    let holding = false;
    let startedAt = 0;
    let raf = null;
    let completed = false;

    const bar = container.querySelector(".progressBar");

    const update = () => {
      if (!holding) return;
      const elapsed = performance.now() - startedAt;
      const p = Math.min(1, elapsed / 2000);
      bar.style.width = (p * 100).toFixed(1) + "%";

      if (p >= 1 && !completed) {
        completed = true;
        holding = false;
        if (raf) cancelAnimationFrame(raf);
        onCompleted();
      } else {
        raf = requestAnimationFrame(update);
      }
    };

    const start = (e) => {
      e.preventDefault();
      if (completed) return;
      if (holding) return;
      holding = true;
      bar.style.width = "0%";
      startedAt = performance.now();
      raf = requestAnimationFrame(update);
    };

    const end = (e) => {
      e.preventDefault();
      if (!holding) return;
      holding = false;
      if (raf) cancelAnimationFrame(raf);
    };

    container.addEventListener("pointerdown", start, {passive:false});
    container.addEventListener("pointerup", end, {passive:false});
    container.addEventListener("pointercancel", end, {passive:false});
    container.addEventListener("pointerleave", end, {passive:false});
  }

  // Hold-to-select (0.5s) with wobble/pop + haptic if supported
  function attachHoldToSelect(tileEl, durationMs, onCompleted) {
    let holding = false;
    let startedAt = 0;
    let raf = null;
    let completed = false;

    const bar = tileEl.querySelector(".tileHoldBar");

    const stop = () => {
      holding = false;
      tileEl.classList.remove("wobbling");
      if (raf) cancelAnimationFrame(raf);
    };

    const update = () => {
      if (!holding) return;
      const elapsed = performance.now() - startedAt;
      const p = Math.min(1, elapsed / durationMs);
      if (bar) bar.style.width = (p * 100).toFixed(1) + "%";

      if (p >= 1 && !completed) {
        completed = true;
        stop();

        tileEl.classList.add("popping");
        hapticTick(18);

        setTimeout(() => {
          tileEl.classList.remove("popping");
          onCompleted();
        }, 120);
      } else {
        raf = requestAnimationFrame(update);
      }
    };

    const start = (e) => {
      e.preventDefault();
      if (completed) return;
      if (tileEl.getAttribute("data-disabled") === "1") return;

      holding = true;
      startedAt = performance.now();
      if (bar) bar.style.width = "0%";
      tileEl.classList.add("wobbling");
      raf = requestAnimationFrame(update);
    };

    const end = (e) => {
      e.preventDefault();
      if (!holding) return;
      stop();
    };

    tileEl.addEventListener("pointerdown", start, { passive:false });
    tileEl.addEventListener("pointerup", end, { passive:false });
    tileEl.addEventListener("pointercancel", end, { passive:false });
    tileEl.addEventListener("pointerleave", end, { passive:false });
  }

  // Render
  function render() {
    switch (state.phase) {
      case "HOME": return renderHome();
      case "ROUND_SETUP": return renderRoundSetup();
      case "REVEAL": return renderReveal();
      case "PASS_NEXT": return renderPassNext();
      case "PLAY_START": return renderPlayStart();
      case "VOTING_TOKENS": return renderVotingTokens();
      case "RESULT": return renderResult();
      default:
        state.phase = "HOME"; save(); return renderHome();
    }
  }

  function renderHome() {
    $app.innerHTML = `
      <div class="card">
        <h1>Detective Club Helper</h1>
        <p class="muted">디텍티브 클럽 보드게임 made by 베이오락실 with chatgpt</p>
        <div class="divider"></div>

        <div class="grid2">
          <div>
            <label>참가자 수</label>
            <input id="N" inputmode="numeric" value="${state.N}" />
          </div>
          <div>
            <label>총 라운드 수 (0 = 무제한)</label>
            <input id="R" inputmode="numeric" value="${state.totalRounds}" />
          </div>
        </div>

        <label>플레이어 이름</label>
        <div id="nameList"></div>

        <button class="btn" id="start">설정 완료 → 라운드 1</button>
        <button class="btn secondary" id="reset">전체 초기화</button>

        <div class="notice">
          iPhone에서는 화면 잠금이 걸리면 흐름이 끊길 수 있어요. 게임 중에는 자동 잠금을 꺼두면 편합니다.
        </div>
      </div>
      ${renderScoreTableCard()}
    `;

    const nameList = document.getElementById("nameList");

    function renderNameInputs(n) {
      let html = "";
      for (let i=1;i<=n;i++) {
        const p = playerById(i);
        const cls = p?.isDefaultName ? "nameInput defaultName" : "nameInput realName";
        html += `
          <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
            ${numTokenHTML(i)}
            <input class="${cls}" data-pid="${i}" value="${escapeHtml(p?.name ?? `Player ${i}`)}" />
          </div>
        `;
      }
      nameList.innerHTML = html;

      nameList.querySelectorAll("input[data-pid]").forEach(inp => {
        inp.addEventListener("focus", (e) => {
          const id = parseInt(e.target.getAttribute("data-pid"), 10);
          const p = playerById(id);
          if (!p) return;

          // ✅ if still default, clear immediately on first focus
          if (p.isDefaultName) {
            e.target.value = "";
          }
        });

        inp.addEventListener("input", (e) => {
          const id = parseInt(e.target.getAttribute("data-pid"), 10);
          const p = playerById(id);
          if (!p) return;

          const v = e.target.value;
          p.name = v;
          // once user types something non-empty, it's no longer default
          if (v.trim().length > 0) {
            p.isDefaultName = false;
            e.target.classList.remove("defaultName");
            e.target.classList.add("realName");
          } else {
            // if emptied, keep as default-ish state but don't reinsert Player i immediately
            // user can leave empty; we will auto-fill later on start.
            p.isDefaultName = true;
            e.target.classList.add("defaultName");
            e.target.classList.remove("realName");
          }
          save();
        });

        inp.addEventListener("blur", (e) => {
          const id = parseInt(e.target.getAttribute("data-pid"), 10);
          const p = playerById(id);
          if (!p) return;

          // If left empty, restore default label for readability
          if ((e.target.value || "").trim().length === 0) {
            p.name = `Player ${id}`;
            p.isDefaultName = true;
            e.target.value = p.name;
            e.target.classList.add("defaultName");
            e.target.classList.remove("realName");
            save();
          }
        });
      });
    }

    renderNameInputs(state.N);

    document.getElementById("N").addEventListener("input", (e) => {
      const n = clampInt(e.target.value, 3, 20, state.N);
      ensurePlayersForN(n);
      save();
      renderNameInputs(n);
      document.querySelectorAll(".card")[1].outerHTML = renderScoreTableCard();
    });

    document.getElementById("start").onclick = () => {
      const N = clampInt(document.getElementById("N").value, 3, 20, state.N);
      const R = clampInt(document.getElementById("R").value, 0, 50, 0);
      ensurePlayersForN(N);

      state.totalRounds = R;
      state.round = 1;
      state.hostId = 1;
      state.keyword = "";
      state.liarId = null;

      // Reset scores (new game) + ensure names
      state.players = state.players.map(p => {
        const name = (p.name || "").trim();
        const finalName = name.length ? name : `Player ${p.id}`;
        const isDef = p.isDefaultName ?? isLooksLikeDefault(finalName, p.id);
        return ({
          ...p,
          score: 0,
          color: p.color || colorForId(p.id),
          name: finalName,
          isDefaultName: isDef,
        });
      });

      save();
      setPhase("ROUND_SETUP");
    };

    document.getElementById("reset").onclick = () => {
      if (confirm("정말 초기화할까요? 점수와 설정이 모두 리셋됩니다.")) resetAll();
    };
  }

  function renderRoundSetup() {
    const hostOptions = state.players.map(p =>
      `<option value="${p.id}" ${p.id===state.hostId?'selected':''}>${escapeHtml(p.name)} (${p.id}번)</option>`
    ).join("");

    $app.innerHTML = `
      <div class="card">
        <div class="row">
          <h1>라운드 ${state.round}</h1>
          <span class="pill">제시자: ${pmarkHTML(state.hostId)}</span>
        </div>
        <p class="muted">제시자는 제시어를 입력합니다. 라이어는 랜덤으로 배정됩니다 (제시자 제외).</p>

        <label>제시자</label>
        <select id="host">${hostOptions}</select>

        <label>제시어</label>
        <input id="keyword" placeholder="예) 우주, 커피, 비 오는 날..." value="${escapeHtml(state.keyword||"")}" />

        <button class="btn" id="go">제시어 분배 시작</button>
        <button class="btn secondary" id="home">홈으로</button>

        <div class="notice">
          리빌 시작 후에는 라이어 정보가 다시 노출되지 않도록 뒤로가기를 막아두었습니다.
        </div>
      </div>
      ${renderScoreTableCard()}
    `;

    document.getElementById("host").onchange = (e) => {
      state.hostId = clampInt(e.target.value, 1, state.N, 1);
      save();
      render();
    };

    document.getElementById("go").onclick = () => {
      const keyword = document.getElementById("keyword").value.trim();
      if (!keyword) { toast("제시어를 입력해 주세요."); return; }
      state.keyword = keyword;
      save();
      startRound();
    };

    document.getElementById("home").onclick = () => setPhase("HOME");
  }

  function renderReveal() {
    const order = state.revealOrder || [];
    const total = order.length;
    if (state.cursor >= total) { finishReveal(); return; }

    const currentId = order[state.cursor];
    const already = !!state.revealed?.[currentId];
    const isLiar = currentId === state.liarId;

    const secretText = isLiar
      ? "당신은 라이어입니다. 제시어를 유추해보세요."
      : `제시어는 “${state.keyword}” 입니다.`;

    $app.innerHTML = `
      <div class="card">
        <div class="row">
          <h1>제시어 확인</h1>
          <span class="pill">${state.cursor+1} / ${total}</span>
        </div>

        <p class="big center">${pmarkHTML(currentId)} 차례</p>

        <div class="pressArea" id="pressArea">
          <p class="center">${already ? "이미 확인했습니다." : "2초간 꾹 눌러 공개하세요."}</p>
          <div class="progressWrap"><div class="progressBar"></div></div>

          <div class="revealBox" id="revealBox">${already ? escapeHtml(secretText) : "(여기에 표시)"}</div>
        </div>

        <button class="btn" id="confirm" ${already ? "" : "disabled"}>다음 참가자에게 넘기기</button>
        <button class="btn secondary" id="abort">라운드 설정으로 (리셋)</button>
      </div>
    `;

    const revealBox = document.getElementById("revealBox");
    const confirmBtn = document.getElementById("confirm");

    if (!already) {
      attachLongPressOnce(document.getElementById("pressArea"), () => {
        state.revealed[currentId] = true;
        save();
        revealBox.style.opacity = "1";
        revealBox.textContent = secretText;
        confirmBtn.disabled = false;
        toast("확인 완료!");
      });
    } else {
      revealBox.style.opacity = "1";
      confirmBtn.disabled = false;
    }

    confirmBtn.onclick = () => {
      if (!state.revealed[currentId]) { toast("먼저 2초간 눌러 확인해 주세요."); return; }
      setPhase("PASS_NEXT");
    };

    document.getElementById("abort").onclick = () => {
      if (confirm("리빌을 중단하고 라운드 설정으로 돌아갈까요? (이번 라운드 진행은 초기화됩니다)")) {
        state.revealOrder = [];
        state.cursor = 0;
        state.revealed = {};
        state.votes = {};
        state.accusations = {};
        state.liarId = null;
        save();
        setPhase("ROUND_SETUP");
      }
    };
  }

  // ✅ PASS_NEXT includes next user
  function renderPassNext() {
    const order = state.revealOrder || [];
    const total = order.length;
    const currentId = order[state.cursor];
    const nextId = (state.cursor + 1 < total) ? order[state.cursor + 1] : state.hostId;

    $app.innerHTML = `
      <div class="card">
        <h1 class="center">다음 사람에게 넘기기</h1>
        <p class="center">이 화면 그대로 <b>다음 사용자에게 휴대폰을 넘겨주세요.</b></p>

        <p class="muted center">
          방금 확인: ${pmarkHTML(currentId)}
          · 다음 사용자: ${pmarkHTML(nextId)}
          · 진행: ${state.cursor+1}/${total}
        </p>

        <button class="btn" id="next">${state.cursor + 1 < total ? "다음 참가자 시작" : "제시자에게 넘기기"}</button>
        <button class="btn secondary" id="back">이전 화면</button>
      </div>
    `;

    document.getElementById("next").onclick = () => {
      state.cursor += 1;
      save();
      setPhase("REVEAL");
    };
    document.getElementById("back").onclick = () => setPhase("REVEAL");
  }

  function renderPlayStart() {
    $app.innerHTML = `
      <div class="card">
        <h1 class="center">게임을 시작합니다!</h1>
        <p class="center">
          오프라인에서 카드 2장씩 내려놓은 뒤,<br/>
          <b>라이어 지목</b>을 진행하세요.
        </p>

        <button class="btn" id="vote">라이어 지목 시작 (토큰)</button>
        <button class="btn secondary" id="setup">라운드 설정으로</button>
      </div>
      ${renderScoreTableCard()}
    `;

    document.getElementById("vote").onclick = () => startVoting();
    document.getElementById("setup").onclick = () => setPhase("ROUND_SETUP");
  }

  function renderVotingTokens() {
    const voters = state.voteOrder || [];
    const targets = state.players.filter(p => p.id !== state.hostId).map(p => p.id);

    if (state.voteCursor >= voters.length) {
      finishVoting();
      return;
    }

    const currentVoterId = voters[state.voteCursor];

    const tokenStacks = {};
    for (const [voterStr, targetStr] of Object.entries(state.votes)) {
      const voterId = parseInt(voterStr, 10);
      const targetId = parseInt(targetStr, 10);
      tokenStacks[targetId] = tokenStacks[targetId] || [];
      tokenStacks[targetId].push(voterId);
    }

    const tilesHtml = targets.map(tid => {
      const votersForThis = tokenStacks[tid] || [];
      const count = votersForThis.length;
      const tokens = votersForThis.slice(0, 14).map(vId => {
        const c = pcolor(vId);
        return `<span class="token" style="--c:${c}" title="${escapeHtml(playerById(vId)?.name || vId)}"></span>`;
      }).join("");
      const more = count > 14 ? `<span class="muted" style="font-weight:900;">+${count-14}</span>` : "";
      const isDisabled = (tid === currentVoterId);

      return `
        <div class="tile ${isDisabled ? "disabled" : ""}" data-target="${tid}" data-disabled="${isDisabled ? "1" : "0"}">
          <div class="badge">${count}</div>
          <div class="tileTitle">${pmarkHTML(tid, true)}</div>
          <div class="tileSub">${tid}번</div>
          <div class="tokenStack">${tokens}${more}</div>
          <div class="tileHoldBarWrap"><div class="tileHoldBar"></div></div>
        </div>
      `;
    }).join("");

    const chips = Object.entries(state.votes)
      .map(([voterStr, targetId]) => {
        const v = parseInt(voterStr, 10);
        const t = parseInt(targetId, 10);
        return `<span class="chip">${pmarkHTML(v, false)} → ${pmarkHTML(t, false)}</span>`;
      }).join("");

    $app.innerHTML = `
      <div class="card">
        <div class="row">
          <h1>라이어 지목 (공개)</h1>
          <span class="pill">${state.voteCursor+1} / ${voters.length}</span>
        </div>

        <p class="big center">지금 차례: ${pmarkHTML(currentVoterId)}</p>
        <p class="center muted">아래에서 라이어라고 생각하는 사람을 <b>0.5초간 꾹</b> 눌러 지목하세요. (자기 자신은 선택 불가)</p>
        <div class="tileHoldHint">짧게 탭하면 선택되지 않습니다.</div>

        <div class="tiles">${tilesHtml}</div>

        <div class="divider"></div>
        <p class="muted center">현재 지목 기록</p>
        <div class="chipRow">${chips || `<span class="muted">아직 없음</span>`}</div>

        <button class="btn secondary" id="undo">이번 차례 되돌리기</button>
        <button class="btn secondary" id="cancel">취소(라운드로)</button>

        <div class="notice">
          제시자(${pmarkHTML(state.hostId)})는 지목 대상에서 제외됩니다.
        </div>
      </div>
    `;

    document.querySelectorAll(".tile[data-target]").forEach(tile => {
      attachHoldToSelect(tile, 500, () => {
        if (tile.getAttribute("data-disabled") === "1") {
          toast("자기 자신은 지목할 수 없어요.");
          return;
        }
        const targetId = parseInt(tile.getAttribute("data-target"), 10);
        registerVote(currentVoterId, targetId);
        state.voteCursor += 1;
        save();
        render();
      });
    });

    document.getElementById("undo").onclick = () => {
      if (state.voteCursor <= 0) { toast("되돌릴 차례가 없어요."); return; }
      const prevVoterId = voters[state.voteCursor - 1];
      delete state.votes[prevVoterId];
      rebuildAccusationsFromVotes();
      state.voteCursor -= 1;
      save();
      toast("한 차례 되돌렸어요.");
      render();
    };

    document.getElementById("cancel").onclick = () => {
      if (confirm("지목을 취소하고 라운드 화면으로 돌아갈까요? (입력된 지목은 초기화됩니다)")) {
        state.votes = {};
        state.accusations = {};
        state.voteOrder = [];
        state.voteCursor = 0;
        save();
        setPhase("ROUND_SETUP");
      }
    };
  }

  function renderResult() {
    const acc = state._lastAccusationCount ?? 0;
    const bonusApplied = acc <= 1;

    $app.innerHTML = `
      <div class="card">
        <h1>라운드 ${state.round} 결과</h1>

        <p><b>라이어:</b> ${pmarkHTML(state.liarId)}</p>
        <p><b>제시자:</b> ${pmarkHTML(state.hostId)}</p>
        <p><b>라이어 지목 수:</b> ${acc}명</p>
        <p><b>보너스:</b> ${bonusApplied ? "적용 (라이어 +5, 제시자 +4)" : "미적용"}</p>

        <div class="divider"></div>
        <h2>점수표</h2>
        ${renderScoreTable()}

        <button class="btn" id="nextRound">다음 라운드</button>
        <button class="btn secondary" id="setup">라운드 설정으로</button>
        <button class="btn danger" id="reset">게임 초기화</button>

        ${renderGameEndHint()}
      </div>
    `;

    document.getElementById("nextRound").onclick = () => {
      if (state.totalRounds > 0 && state.round >= state.totalRounds) {
        toast("설정한 총 라운드 수에 도달했습니다. (홈에서 변경 가능)");
        setPhase("HOME");
        return;
      }
      nextRound();
    };

    document.getElementById("setup").onclick = () => setPhase("ROUND_SETUP");
    document.getElementById("reset").onclick = () => {
      if (confirm("정말 초기화할까요?")) resetAll();
    };
  }

  function renderScoreTable() {
    let rows = "";
    for (let i=1;i<=state.N;i++) {
      const p = playerById(i);
      const c = p?.color || colorForId(i);
      const bg = hexToRgba(c, 0.25);
      rows += `
        <tr>
          <td>
            <span class="pmark" style="--c:${c};--bg:${bg}">
              <span class="dot" style="--c:${c}"></span>
              <span>${escapeHtml(p?.name ?? `Player ${i}`)}</span>
              <span class="pno">${i}번</span>
            </span>
          </td>
          <td style="font-weight:900;">${p?.score ?? 0}</td>
        </tr>
      `;
    }
    return `
      <table>
        <thead><tr><th>플레이어</th><th>점수</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function renderScoreTableCard() {
    return `
      <div class="card">
        <h2>점수표</h2>
        ${renderScoreTable()}
      </div>
    `;
  }

  function renderGameEndHint() {
    if (state.totalRounds > 0) {
      return `<p class="muted">총 라운드 수: ${state.totalRounds} · 현재: ${state.round}</p>`;
    }
    return `<p class="muted">총 라운드 수: 무제한</p>`;
  }

  function escapeHtml(str) {
    return (str ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");
  }

  render();
})();
</script>
</body>
</html>
