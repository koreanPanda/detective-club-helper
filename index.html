<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Detective Club Helper</title>
  <style>
    :root { --pad:18px; --radius:16px; --shadow:0 10px 30px rgba(0,0,0,.08); }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple SD Gothic Neo","Noto Sans KR",sans-serif;
      background:#f6f7fb; color:#111;
      min-height:100vh; display:flex; justify-content:center;
      -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;
    }
    .app{ width:min(620px,100%); padding:var(--pad); padding-bottom:calc(var(--pad) + env(safe-area-inset-bottom)); }
    .card{ background:#fff; border-radius:var(--radius); box-shadow:var(--shadow); padding:var(--pad); margin:10px 0; }
    h1{ font-size:22px; margin:0 0 8px; }
    h2{ font-size:18px; margin:0 0 8px; }
    p{ margin:8px 0; line-height:1.45; color:#333; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .center{ text-align:center; }
    .muted{ color:#666; font-size:13px; }
    .divider{ height:1px; background:#eef0f6; margin:14px 0; }

    label{ font-size:13px; color:#444; display:block; margin:12px 0 6px; }
    input, select{
      width:100%; padding:12px 12px;
      border:1px solid #d8dbe6; border-radius:12px;
      font-size:16px; outline:none; background:#fff; color:#111;
      -webkit-user-select:text !important; user-select:text !important;
      -webkit-touch-callout:default !important;
    }
    input:focus, select:focus{ border-color:#7aa7ff; box-shadow:0 0 0 3px rgba(122,167,255,.25); }

    .btn{
      width:100%; padding:14px 14px;
      border:0; border-radius:14px;
      font-size:16px; font-weight:900;
      background:#111; color:#fff; cursor:pointer;
      margin-top:12px;
    }
    .btn.secondary{ background:#e9ecf6; color:#111; }
    .btn.danger{ background:#d62828; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn:active{ transform:translateY(1px); }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px; border-radius:999px;
      background:#f0f2f9; color:#222;
      font-size:13px; font-weight:800;
    }

    .grid2{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    @media (max-width:420px){ .grid2{ grid-template-columns:1fr; } }

    .notice{
      font-size:12px; color:#666; margin-top:10px;
      background:#f5f7ff; border:1px solid #e1e7ff;
      padding:10px 12px; border-radius:12px;
    }

    .pmark{
      display:inline-flex; align-items:center; gap:8px;
      padding:4px 10px; border-radius:999px;
      font-weight:900; color:#111;
      background:var(--bg,#f0f2f9);
      border:1px solid rgba(0,0,0,.06);
      box-shadow:0 6px 18px rgba(0,0,0,.06);
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background:var(--c,#111);
      box-shadow:0 2px 6px rgba(0,0,0,.12);
      flex:0 0 auto;
    }
    .pno{ font-weight:900; color:#333; opacity:.75; font-size:12px; }

    .numToken{
      display:inline-flex; align-items:center; justify-content:center;
      min-width:72px; height:40px; padding:0 12px;
      border-radius:999px; font-weight:900;
      border:1px solid rgba(0,0,0,.06);
      box-shadow:0 6px 18px rgba(0,0,0,.06);
      background:var(--bg,#f0f2f9); color:#111; gap:8px;
      flex:0 0 auto;
    }
    .nameInput.defaultName{ color:#9aa0ad; font-weight:800; }
    .nameInput.realName{ color:#111; font-weight:900; }

    .pressArea{
      user-select:none; -webkit-user-select:none; -webkit-touch-callout:none;
      touch-action:manipulation;
      border:2px dashed #d8dbe6;
      border-radius:18px;
      padding:18px;
      margin-top:12px;
      background:#fbfcff;
    }
    .progressWrap{ height:10px; background:#eef0f6; border-radius:999px; overflow:hidden; }
    .progressBar{ height:10px; width:0%; background:#111; transition:width .05s linear; }
    .revealBox{
      border-radius:18px;
      padding:18px;
      background:#111;
      color:#fff;
      margin-top:12px;
      min-height:86px;
      display:flex; align-items:center; justify-content:center;
      text-align:center;
      font-size:18px; font-weight:900;
      opacity:.10;
    }

    .tiles{ display:grid; grid-template-columns:repeat(2,minmax(0,1fr)); gap:10px; margin-top:12px; }
    @media (max-width:420px){ .tiles{ grid-template-columns:1fr; } }
    .tile{
      border:1px solid #e7eaf4;
      border-radius:16px;
      padding:14px;
      background:#fff;
      box-shadow:0 6px 18px rgba(0,0,0,.05);
      cursor:pointer;
      user-select:none;
      position:relative;
      touch-action:manipulation;
      -webkit-touch-callout:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .tileTitle{ font-weight:900; font-size:16px; margin:0; }
    .tileSub{ font-size:12px; color:#666; margin-top:4px; }
    .tile.disabled{ opacity:.45; cursor:not-allowed; box-shadow:none; }

    .tileHoldBarWrap{
      height:8px; background:#eef0f6;
      border-radius:999px; overflow:hidden; margin-top:10px;
    }
    .tileHoldBar{ height:8px; width:0%; background:#111; transition:width .05s linear; }
    .tileHoldHint{ font-size:12px; color:#666; margin-top:8px; text-align:center; }

    @keyframes wobble{
      0%{transform:translateX(0) rotate(0)}
      15%{transform:translateX(-1px) rotate(-0.6deg)}
      30%{transform:translateX(1px) rotate(0.6deg)}
      45%{transform:translateX(-1px) rotate(-0.6deg)}
      60%{transform:translateX(1px) rotate(0.6deg)}
      75%{transform:translateX(-0.5px) rotate(-0.3deg)}
      100%{transform:translateX(0) rotate(0)}
    }
    @keyframes pop{ 0%{transform:scale(1)} 50%{transform:scale(.97)} 100%{transform:scale(1.02)} }

    .tile.selected{
      animation:wobble 140ms linear infinite;
      border-color:rgba(0,0,0,.20);
      box-shadow:0 10px 24px rgba(0,0,0,.12);
    }
    .tile.popping{ animation:pop 120ms ease-out 1; }

    /* roulette */
    .rouletteBox{
      border-radius:18px;
      padding:18px;
      background:#111;
      color:#fff;
      margin-top:12px;
      min-height:120px;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .rouletteName{ font-size:24px; font-weight:1000; letter-spacing:.2px; }
    .rouletteSub{ opacity:.85; margin-top:8px; font-size:13px; }

    .deltaList{ display:flex; flex-direction:column; gap:10px; margin-top:14px; }
    .deltaRow{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid #eef0f6;
      background:#fff;
      box-shadow:0 6px 18px rgba(0,0,0,.05);
    }
    .deltaVal{
      font-weight:1000; font-size:16px;
      padding:6px 10px; border-radius:999px;
      background:#f0f2f9; border:1px solid #e2e6f2;
      min-width:64px; text-align:center;
    }

    /* iOS selection/callout hard block on game surfaces */
    .pressArea, .tile, .rouletteBox {
      -webkit-user-select:none !important;
      user-select:none !important;
      -webkit-touch-callout:none !important;
    }
  </style>
</head>
<body>
  <div class="app" id="app"></div>

<script>
(() => {
  const STORAGE_KEY = "dc_helper_final_banner_stamp";

  const PASTELS = [
    "#FFD6A5","#FDFFB6","#CAFFBF","#9BF6FF","#A0C4FF",
    "#BDB2FF","#FFC6FF","#FFADAD","#CDEAC0","#B9FBC0",
    "#D0F4DE","#FDE2E4","#E2F0CB","#CFBAF0","#F1C0E8",
    "#F9F9C5","#BEE1E6","#EAC4D5","#C6DEF1","#F2C6DE"
  ];

  const defaultState = {
    mode: "LITE", // default LITE
    N: 6,
    totalRounds: 0, // 0 = infinite
    round: 1,
    phase: "HOME",
    players: [],
    hostId: 1,
    liarId: null,
    keyword: "",
    revealOrder: [],
    cursor: 0,
    revealed: {},
    voteOrder: [],
    voteCursor: 0,
    votes: {},
    accusations: {},
    lastRoundDelta: {},
    _lastAccCount: 0,
    roulette: { running:false, show:false, shownName:"", done:false }, // âœ… ì½¤ë§ˆ í•„ìˆ˜
    roundHistory: []  // âœ… ê° ë¼ìš´ë“œ Î” ê¸°ë¡ [{ round, hostId, liarId, accCount, delta:{1:..} }]
  };

  let state = load() || initDefault();

  function initDefault(){
    const s = structuredClone(defaultState);
    s.players = [];
    for(let i=1;i<=s.N;i++){
      s.players.push({ id:i, name:`Player ${i}`, score:0, color:colorForId(i), isDefaultName:true });
    }
    s.hostId = 1;
    return s;
  }

  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return null;
      const obj = JSON.parse(raw);

      obj.mode = obj.mode || "LITE";
      obj.players = (obj.players||[]).map(p => ({
        ...p,
        color: p.color || colorForId(p.id),
        isDefaultName: (typeof p.isDefaultName==="boolean") ? p.isDefaultName : isLooksLikeDefault(p.name, p.id)
      }));
      obj.lastRoundDelta = obj.lastRoundDelta || {};
      obj.roundHistory = obj.roundHistory || [];
      obj.roulette = obj.roulette || { running:false, show:false, shownName:"", done:false };
      return obj;
    }catch{
      return null;
    }
  }

  // âœ… ì™„ì „ ì´ˆê¸°í™” (ì ìˆ˜/ê¸°ë¡/ì„¤ì • í¬í•¨)
  function resetAll(){
    localStorage.removeItem(STORAGE_KEY);
    state = initDefault();
    save();
    render();
  }

  // Disable browser back (anti-cheat)
  history.pushState({locked:true}, "");
  window.addEventListener("popstate", () => {
    history.pushState({locked:true}, "");
    toast("ë’¤ë¡œê°€ê¸°ëŠ” ë¹„í™œì„±í™”ë˜ì–´ ìˆì–´ìš”. (ì¹˜íŒ… ë°©ì§€)");
  });

  // Prevent selection on iOS after long press
  function clearTextSelection(){
    try{
      const sel = window.getSelection?.();
      if(sel && sel.rangeCount) sel.removeAllRanges();
    }catch{}
  }
  document.addEventListener("selectionchange", () => {
    const a = document.activeElement;
    const typing = a && (a.tagName==="INPUT" || a.tagName==="TEXTAREA");
    if(typing) return;
    clearTextSelection();
  });
  document.addEventListener("contextmenu", (e)=>{
    const t=e.target;
    if(t && (t.closest(".pressArea") || t.closest(".tile") || t.closest(".rouletteBox"))){
      e.preventDefault();
    }
  }, {capture:true});

  function toast(msg){
    const id="toast";
    let el=document.getElementById(id);
    if(!el){
      el=document.createElement("div");
      el.id=id;
      el.style.position="fixed";
      el.style.left="50%";
      el.style.bottom="20px";
      el.style.transform="translateX(-50%)";
      el.style.background="rgba(17,17,17,.92)";
      el.style.color="#fff";
      el.style.padding="10px 12px";
      el.style.borderRadius="12px";
      el.style.fontSize="13px";
      el.style.zIndex="9999";
      document.body.appendChild(el);
    }
    el.textContent=msg;
    el.style.display="block";
    clearTimeout(toast._t);
    toast._t=setTimeout(()=>{ el.style.display="none"; },1600);
  }
  function haptic(ms=18){ try{ if(navigator.vibrate) navigator.vibrate(ms); }catch{} }

  const $app = document.getElementById("app");
  function setPhase(p){ state.phase=p; save(); render(); }

  function clampInt(v,min,max,fallback){
    const n=parseInt(v,10);
    if(Number.isNaN(n)) return fallback;
    return Math.min(max, Math.max(min, n));
  }
  function colorForId(id){ return PASTELS[(id-1)%PASTELS.length]; }
  function hexToRgba(hex,a){
    const h=(hex||"").replace("#","");
    const v=h.length===3 ? h.split("").map(ch=>ch+ch).join("") : h;
    const r=parseInt(v.slice(0,2),16);
    const g=parseInt(v.slice(2,4),16);
    const b=parseInt(v.slice(4,6),16);
    return `rgba(${r},${g},${b},${a})`;
  }
  function playerById(id){ return state.players.find(p=>p.id===id); }
  function pcolor(id){ return playerById(id)?.color || colorForId(id); }
  function isLooksLikeDefault(name,id){ return (name||"").trim()===`Player ${id}`; }

  function pmarkHTML(id, withNo=true){
    const p=playerById(id);
    const name=p?.name ?? `${id}ë²ˆ`;
    const c=pcolor(id);
    const bg=hexToRgba(c,0.28);
    return `
      <span class="pmark" style="--c:${c};--bg:${bg}">
        <span class="dot" style="--c:${c}"></span>
        <span>${escapeHtml(name)}</span>
        ${withNo ? `<span class="pno">${id}ë²ˆ</span>` : ``}
      </span>
    `;
  }
  function numTokenHTML(id){
    const c=pcolor(id);
    const bg=hexToRgba(c,0.28);
    return `
      <div class="numToken" style="--c:${c};--bg:${bg}">
        <span class="dot" style="--c:${c}"></span>
        <span>${id}ë²ˆ</span>
      </div>
    `;
  }

  function ensurePlayersForN(newN){
    const prev=new Map(state.players.map(p=>[p.id,p]));
    const next=[];
    for(let i=1;i<=newN;i++){
      const old=prev.get(i);
      const name=old?.name ?? `Player ${i}`;
      const isDef=(typeof old?.isDefaultName==="boolean") ? old.isDefaultName : isLooksLikeDefault(name,i);
      next.push({ id:i, name, score:old?.score??0, color:old?.color??colorForId(i), isDefaultName:isDef });
    }
    state.players=next;
    state.N=newN;
    if(state.hostId>newN) state.hostId=1;
  }

  // Order: start AFTER host, wrap around, exclude host
  function makeOrderAfterHost(N, hostId){
    const arr=[];
    let x=(hostId % N) + 1;
    while(arr.length < N-1){
      if(x !== hostId) arr.push(x);
      x=(x % N) + 1;
    }
    return arr;
  }
  function pickRandom(arr){ return arr?.length ? arr[Math.floor(Math.random()*arr.length)] : null; }
  function nextHostId(host,N){ return (host % N) + 1; }

  function attachLongPressOnce(container, onCompleted){
    let holding=false, startedAt=0, raf=null, completed=false;
    const bar=container.querySelector(".progressBar");

    const update=()=>{
      if(!holding) return;
      const elapsed=performance.now()-startedAt;
      const p=Math.min(1, elapsed/2000);
      bar.style.width=(p*100).toFixed(1)+"%";
      if(p>=1 && !completed){
        completed=true; holding=false;
        if(raf) cancelAnimationFrame(raf);
        clearTextSelection();
        onCompleted();
      }else{
        raf=requestAnimationFrame(update);
      }
    };

    const start=(e)=>{
      if(e.cancelable) e.preventDefault();
      clearTextSelection();
      if(completed||holding) return;
      holding=true; bar.style.width="0%";
      startedAt=performance.now();
      raf=requestAnimationFrame(update);
    };
    const end=(e)=>{
      if(e.cancelable) e.preventDefault();
      clearTextSelection();
      if(!holding) return;
      holding=false;
      if(raf) cancelAnimationFrame(raf);
    };

    container.addEventListener("pointerdown", start, {passive:false});
    container.addEventListener("pointerup", end, {passive:false});
    container.addEventListener("pointercancel", end, {passive:false});
    container.addEventListener("pointerleave", end, {passive:false});
    container.addEventListener("contextmenu", (e)=>e.preventDefault());
    container.addEventListener("selectstart", (e)=>e.preventDefault());
  }

  function startRound(){
    state.keyword=(state.keyword||"").trim();
    // âœ… ì œì‹œì–´ í™•ì¸ ìˆœì„œ: ì œì‹œì ë‹¤ìŒë¶€í„° ìœ ì§€
    state.revealOrder=makeOrderAfterHost(state.N, state.hostId);
    state.cursor=0;
    state.revealed={};
    state.votes={};
    state.accusations={};
    state.voteOrder=[];
    state.voteCursor=0;
    state.lastRoundDelta={};
    state._lastAccCount=0;
    state.roulette={ running:false, show:false, shownName:"", done:false };

    // liar is random among non-host players
    state.liarId = pickRandom(state.revealOrder);
    save();
    setPhase("REVEAL");
  }

  function startVoting(){
    // âœ… íˆ¬í‘œ ì§„í–‰ ìˆœì„œëŠ” ê¸°ì¡´ ìœ ì§€(ì œì‹œì ë‹¤ìŒë¶€í„°)
    state.voteOrder = makeOrderAfterHost(state.N, state.hostId);
    state.voteCursor=0;
    state.votes={};
    state.accusations={};
    save();
    setPhase("VOTING");
  }

  function rebuildAccusations(){
    const acc={};
    for(const [voterStr,targetStr] of Object.entries(state.votes)){
      const tid=parseInt(targetStr,10);
      acc[tid]=(acc[tid]||0)+1;
    }
    state.accusations=acc;
  }

  function registerVote(voterId,targetId){
    state.votes[voterId]=targetId;
    rebuildAccusations();
  }

  function applyScoring(){
    const hostId=state.hostId;
    const liarId=state.liarId;
    const accCount = state.accusations[liarId] || 0;
    state._lastAccCount = accCount;

    const delta={}; for(let i=1;i<=state.N;i++) delta[i]=0;

    // Correct accuser +3 (non-host only)
    for(const voterIdStr of Object.keys(state.votes)){
      const voterId=parseInt(voterIdStr,10);
      if(voterId===hostId) continue;
      if(parseInt(state.votes[voterId],10)===liarId){
        delta[voterId]+=3;
      }
    }
    // Liar success (<=1 accusation): liar +5, host +4
    if(accCount<=1){
      delta[liarId]+=5;
      delta[hostId]+=4;
    }

    for(let i=1;i<=state.N;i++){
      const p=playerById(i);
      if(p) p.score += (delta[i]||0);
    }
    state.lastRoundDelta=delta;

    state.roundHistory = state.roundHistory || [];
    state.roundHistory.push({
      round: state.round,
      hostId: state.hostId,
      liarId: state.liarId,
      accCount: state._lastAccCount || 0,
      delta: { ...delta }
    });
    save();
  }

  function maybeEndByRoundLimit(){
    if(state.totalRounds>0 && state.round>=state.totalRounds){
      setPhase("GAME_END");
      return true;
    }
    return false;
  }

  function nextRound(){
    state.round += 1;
    state.hostId = nextHostId(state.hostId, state.N);
    state.keyword="";
    state.liarId=null;
    state.revealOrder=[];
    state.cursor=0;
    state.revealed={};
    state.votes={};
    state.accusations={};
    state.voteOrder=[];
    state.voteCursor=0;
    state.lastRoundDelta={};
    state._lastAccCount=0;
    state.roulette={ running:false, show:false, shownName:"", done:false };
    save();
    setPhase("ROUND_SETUP");
  }

  // Roulette: show fast cycling, then final liar
  function startRoulette(){
    if(state.roulette.running) return;
    state.roulette.running=true;
    state.roulette.done=false;
    state.roulette.show=true;
    state.roulette.shownName="";
    save();

    const ids = makeOrderAfterHost(state.N, state.hostId); // candidates (non-host)
    const names = ids.map(id => playerById(id)?.name || `Player ${id}`);
    let i=0;

    const totalMs = 2800;
    const start = performance.now();

    const tick = () => {
      const t = performance.now() - start;
      state.roulette.shownName = names[i % names.length];
      save();
      render();
      i++;

      if(t >= totalMs){
        state.roulette.running=false;
        state.roulette.done=true;
        state.roulette.shownName = playerById(state.liarId)?.name || `Player ${state.liarId}`;
        save();
        render();
        haptic(28);
        return;
      }

      const k = t / totalMs;
      const base = 55;
      const slow = 210 * (k*k);
      const nextDelay = Math.round(base + slow);
      setTimeout(tick, nextDelay);
    };

    tick();
  }

  function render(){
    switch(state.phase){
      case "HOME": return renderHome();
      case "ROUND_SETUP": return renderRoundSetup();
      case "REVEAL": return renderReveal();
      case "PASS_NEXT": return renderPassNext();
      case "PLAY_START": return renderPlayStart();
      case "KEYWORD_RECAP": return renderKeywordRecap();
      case "VOTING": return renderVoting();
      case "RESULT_ROULETTE": return renderResultRoulette();
      case "GAME_END": return renderGameEnd();
      default: state.phase="HOME"; save(); return renderHome();
    }
  }

  function renderHome(){
    $app.innerHTML=`
      <div class="card">
        <h1>Detective Club Helper</h1>
        <p class="muted">ë””í…í‹°ë¸Œ í´ëŸ½ ë³´ë“œê²Œì„ made by ë² ì´ì˜¤ë½ì‹¤ with chatgpt</p>
        <div class="divider"></div>

        <label>ëª¨ë“œ ì„ íƒ</label>
        <select id="mode">
          <option value="LITE" ${state.mode==="LITE"?"selected":""}>LITE (íƒ­ìœ¼ë¡œ ë¹ ë¥´ê²Œ íˆ¬í‘œ)</option>
          <option value="FULL" ${state.mode==="FULL"?"selected":""}>FULL (ì»´í¬ë„ŒíŠ¸ ì—†ì„ë•Œ)</option>
        </select>

        <div class="grid2">
          <div>
            <label>ì°¸ê°€ì ìˆ˜</label>
            <input id="N" inputmode="numeric" value="${state.N}" />
          </div>
          <div>
            <label>ì´ ë¼ìš´ë“œ ìˆ˜ (0 = ë¬´ì œí•œ)</label>
            <input id="R" inputmode="numeric" value="${state.totalRounds}" />
          </div>
        </div>

        <label>í”Œë ˆì´ì–´ ì´ë¦„</label>
        <div id="nameList"></div>

        <button class="btn" id="start">ì„¤ì • ì™„ë£Œ â†’ ë¼ìš´ë“œ 1</button>
        <button class="btn secondary" id="reset">ì „ì²´ ì´ˆê¸°í™”</button>

        <div class="notice">iPhoneì—ì„œ ìë™ ì ê¸ˆ OFF ì¶”ì²œ (ê²Œì„ íë¦„ ìœ ì§€)</div>
      </div>
    `;

    document.getElementById("mode").onchange=(e)=>{ state.mode=e.target.value; save(); };

    const nameList=document.getElementById("nameList");
    function renderNameInputs(n){
      let html="";
      for(let i=1;i<=n;i++){
        const p=playerById(i);
        const cls=p?.isDefaultName ? "nameInput defaultName" : "nameInput realName";
        html += `
          <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
            ${numTokenHTML(i)}
            <input class="${cls}" data-pid="${i}" value="${escapeHtml(p?.name ?? `Player ${i}`)}" />
          </div>
        `;
      }
      nameList.innerHTML=html;

      nameList.querySelectorAll("input[data-pid]").forEach(inp=>{
        inp.addEventListener("focus",(e)=>{
          const id=parseInt(e.target.getAttribute("data-pid"),10);
          const p=playerById(id);
          if(p?.isDefaultName) e.target.value="";
        });
        inp.addEventListener("input",(e)=>{
          const id=parseInt(e.target.getAttribute("data-pid"),10);
          const p=playerById(id);
          if(!p) return;
          const v=e.target.value;
          p.name=v;
          if(v.trim().length>0){
            p.isDefaultName=false;
            e.target.classList.remove("defaultName");
            e.target.classList.add("realName");
          }else{
            p.isDefaultName=true;
            e.target.classList.add("defaultName");
            e.target.classList.remove("realName");
          }
          save();
        });
        inp.addEventListener("blur",(e)=>{
          const id=parseInt(e.target.getAttribute("data-pid"),10);
          const p=playerById(id);
          if(!p) return;
          if((e.target.value||"").trim().length===0){
            p.name=`Player ${id}`;
            p.isDefaultName=true;
            e.target.value=p.name;
            e.target.classList.add("defaultName");
            e.target.classList.remove("realName");
            save();
          }
        });
      });
    }
    renderNameInputs(state.N);

    document.getElementById("N").addEventListener("input",(e)=>{
      const n=clampInt(e.target.value,3,20,state.N);
      ensurePlayersForN(n); save(); renderNameInputs(n);
    });

    document.getElementById("start").onclick=()=>{
      const N=clampInt(document.getElementById("N").value,3,20,state.N);
      const R=clampInt(document.getElementById("R").value,0,50,0);
      ensurePlayersForN(N);
      state.totalRounds=R;

      // âœ… ìƒˆ ê²Œì„ ì‹œì‘ ì‹œ ì™„ì „ ì´ˆê¸°í™”
      state.round=1;
      state.hostId=1;
      state.keyword="";
      state.liarId=null;

      state.players = state.players.map(p=>{
        const name=(p.name||"").trim();
        const finalName=name.length? name : `Player ${p.id}`;
        const isDef=p.isDefaultName ?? isLooksLikeDefault(finalName,p.id);
        return ({...p, score:0, color:p.color||colorForId(p.id), name:finalName, isDefaultName:isDef});
      });

      state.roundHistory = [];      // âœ… ê¸°ë¡ ì´ˆê¸°í™”
      state.lastRoundDelta = {};    // âœ… Î” ì´ˆê¸°í™”
      state._lastAccCount=0;
      state.roulette={ running:false, show:false, shownName:"", done:false };

      save();
      setPhase("ROUND_SETUP");
    };

    document.getElementById("reset").onclick=()=>{
      if(confirm("ì •ë§ ì´ˆê¸°í™”í• ê¹Œìš”? ì ìˆ˜ì™€ ì„¤ì •ì´ ëª¨ë‘ ë¦¬ì…‹ë©ë‹ˆë‹¤.")) resetAll();
    };
  }

  function renderRoundSetup(){
    const hostOptions = state.players.map(p =>
      `<option value="${p.id}" ${p.id===state.hostId?'selected':''}>${escapeHtml(p.name)} (${p.id}ë²ˆ)</option>`
    ).join("");
    const hostScore = playerById(state.hostId)?.score ?? 0;

    $app.innerHTML=`
      <div class="card">
        <div class="row">
          <h1>ë¼ìš´ë“œ ${state.round}</h1>
          <span class="pill">ì œì‹œì: ${pmarkHTML(state.hostId)}</span>
        </div>

        <p class="muted">ì œì‹œì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”. (ë¼ì´ì–´ëŠ” ëœë¤, ì œì‹œìëŠ” ëª¨ë¦„)</p>
        <p class="muted">â€» ì œì‹œìì—ê²Œë§Œ ë³´ì„ Â· í˜„ì¬ ëˆ„ì  ì ìˆ˜: <b>${hostScore}</b></p>

        <label>ì œì‹œì</label>
        <select id="host">${hostOptions}</select>

        <label>ì œì‹œì–´</label>
        <input id="keyword" placeholder="ì˜ˆ) ìš°ì£¼, ì»¤í”¼, ë¹„ ì˜¤ëŠ” ë‚ ..." value="${escapeHtml(state.keyword||"")}" />

        <button class="btn" id="go">ì œì‹œì–´ ë¶„ë°° ì‹œì‘</button>
        <button class="btn secondary" id="home">í™ˆìœ¼ë¡œ</button>

        ${state.totalRounds===0 ? `<button class="btn danger" id="endGame">ê²Œì„ ì¢…ë£Œ (ì ìˆ˜í‘œ ê³µê°œ)</button>` : ``}
      </div>
    `;

    document.getElementById("host").onchange=(e)=>{ state.hostId=clampInt(e.target.value,1,state.N,1); save(); render(); };
    document.getElementById("go").onclick=()=>{
      const kw=(document.getElementById("keyword").value||"").trim();
      if(!kw){ toast("ì œì‹œì–´ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”."); return; }
      state.keyword=kw; save(); startRound();
    };
    document.getElementById("home").onclick=()=>setPhase("HOME");
    const endBtn=document.getElementById("endGame");
    if(endBtn){
      endBtn.onclick=()=>{
        if(confirm("ì§€ê¸ˆ ê²Œì„ì„ ì¢…ë£Œí•˜ê³  ì „ì²´ ì ìˆ˜í‘œë¥¼ ê³µê°œí• ê¹Œìš”?")){
          setPhase("GAME_END");
        }
      };
    }
  }

  function renderReveal(){
    const order=state.revealOrder||[];
    const total=order.length;
    if(state.cursor>=total){ setPhase("PLAY_START"); return; }

    const currentId=order[state.cursor];
    const already=!!state.revealed?.[currentId];
    const isLiar=(currentId===state.liarId);
    const secretText=isLiar ? "ë‹¹ì‹ ì€ ë¼ì´ì–´ì…ë‹ˆë‹¤. ì œì‹œì–´ë¥¼ ìœ ì¶”í•´ë³´ì„¸ìš”." : `ì œì‹œì–´ëŠ” â€œ${state.keyword}â€ ì…ë‹ˆë‹¤.`;
    const curScore = playerById(currentId)?.score ?? 0;

    $app.innerHTML=`
      <div class="card">
        <div class="row">
          <h1>ì œì‹œì–´ í™•ì¸</h1>
          <span class="pill">${state.cursor+1} / ${total}</span>
        </div>

        <p class="center" style="font-size:22px; font-weight:1000; margin:8px 0 4px;">${pmarkHTML(currentId)} ì°¨ë¡€</p>
        <p class="muted center">â€» ì´ í™”ë©´ì„ ë³´ê³  ìˆëŠ” ì‚¬ëŒì—ê²Œë§Œ ë³´ì„ Â· í˜„ì¬ ëˆ„ì  ì ìˆ˜: <b>${curScore}</b></p>

        <div class="pressArea" id="pressArea">
          <p class="center">${already ? "ì´ë¯¸ í™•ì¸í–ˆìŠµë‹ˆë‹¤." : "2ì´ˆê°„ ê¾¹ ëˆŒëŸ¬ ê³µê°œí•˜ì„¸ìš”."}</p>
          <div class="progressWrap"><div class="progressBar"></div></div>
          <div class="revealBox" id="revealBox">${already ? escapeHtml(secretText) : "(ì—¬ê¸°ì— í‘œì‹œ)"}</div>
        </div>

        <button class="btn" id="confirm" ${already ? "" : "disabled"}>ë‹¤ìŒ ì°¸ê°€ìì—ê²Œ ë„˜ê¸°ê¸°</button>
        <button class="btn secondary" id="abort">ë¼ìš´ë“œ ì„¤ì •ìœ¼ë¡œ (ë¦¬ì…‹)</button>
      </div>
    `;

    const revealBox=document.getElementById("revealBox");
    const confirmBtn=document.getElementById("confirm");

    if(!already){
      attachLongPressOnce(document.getElementById("pressArea"), ()=>{
        state.revealed[currentId]=true; save();
        revealBox.style.opacity="1";
        revealBox.textContent=secretText;
        confirmBtn.disabled=false;
        toast("í™•ì¸ ì™„ë£Œ!");
      });
    }else{
      revealBox.style.opacity="1";
      confirmBtn.disabled=false;
    }

    confirmBtn.onclick=()=>{ if(!state.revealed[currentId]) return; setPhase("PASS_NEXT"); };

    document.getElementById("abort").onclick=()=>{
      if(confirm("ë¦¬ë¹Œì„ ì¤‘ë‹¨í•˜ê³  ë¼ìš´ë“œ ì„¤ì •ìœ¼ë¡œ ëŒì•„ê°ˆê¹Œìš”? (ì´ë²ˆ ë¼ìš´ë“œ ì§„í–‰ì€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤)")){
        state.revealOrder=[]; state.cursor=0; state.revealed={};
        state.votes={}; state.accusations={}; state.liarId=null;
        state.voteOrder=[]; state.voteCursor=0;
        state.lastRoundDelta={}; state._lastAccCount=0;
        state.roulette={ running:false, show:false, shownName:"", done:false };
        save(); setPhase("ROUND_SETUP");
      }
    };
  }

  function renderPassNext(){
    const order=state.revealOrder||[];
    const total=order.length;
    const currentId=order[state.cursor];
    const nextId=(state.cursor+1<total) ? order[state.cursor+1] : state.hostId;

    $app.innerHTML=`
      <div class="card">
        <h1 class="center">ë‹¤ìŒ ì‚¬ëŒì—ê²Œ ë„˜ê¸°ê¸°</h1>
        <p class="center">ì´ í™”ë©´ ê·¸ëŒ€ë¡œ <b>ë‹¤ìŒ ì‚¬ìš©ìì—ê²Œ íœ´ëŒ€í°ì„ ë„˜ê²¨ì£¼ì„¸ìš”.</b></p>
        <p class="muted center">
          ë°©ê¸ˆ í™•ì¸: ${pmarkHTML(currentId)}
          Â· ë‹¤ìŒ ì‚¬ìš©ì: ${pmarkHTML(nextId)}
          Â· ì§„í–‰: ${state.cursor+1}/${total}
        </p>
        <button class="btn" id="next">${state.cursor+1<total ? "ë‹¤ìŒ ì°¸ê°€ì ì‹œì‘" : "ì œì‹œìì—ê²Œ ëŒì•„ê°€ê¸°"}</button>
      </div>
    `;

    document.getElementById("next").onclick=()=>{
      state.cursor+=1; save(); setPhase("REVEAL");
    };
  }

  function renderPlayStart(){
    $app.innerHTML=`
      <div class="card">
        <h1 class="center">ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!</h1>
        <p class="center">ì˜¤í”„ë¼ì¸ì—ì„œ ì¹´ë“œ 2ì¥ì”© ë‚´ë ¤ë†“ê³  í† ë¡  í›„,<br/><b>ë¼ì´ì–´ ì§€ëª©</b>ì„ ì§„í–‰í•˜ì„¸ìš”.</p>

        <button class="btn" id="goRecap">ë¼ì´ì–´ ì§€ëª©ìœ¼ë¡œ</button>
        <button class="btn secondary" id="setup">ë¼ìš´ë“œ ì„¤ì •ìœ¼ë¡œ</button>
      </div>
    `;
    document.getElementById("goRecap").onclick=()=>setPhase("KEYWORD_RECAP");
    document.getElementById("setup").onclick=()=>setPhase("ROUND_SETUP");
  }

  function renderKeywordRecap(){
    $app.innerHTML=`
      <div class="card">
        <h1 class="center">ì œì‹œì–´ ë¦¬ë§ˆì¸ë“œ</h1>
        <p class="center muted">ì§€ëª© ì‹œì‘ ì „ì— ì œì‹œì–´ë¥¼ ë‹¤ì‹œ í™•ì¸í•˜ì„¸ìš”.</p>

        <div class="rouletteBox" style="background:#fff;color:#111;border:1px solid #eef0f6;">
          <div style="font-weight:1000; font-size:20px;">â€œ${escapeHtml(state.keyword)}â€</div>
          <div class="muted" style="margin-top:6px;">â€» ë¼ì´ì–´ëŠ” ì œì‹œì–´ë¥¼ ëª¨ë¦…ë‹ˆë‹¤</div>
        </div>

        <button class="btn" id="startVote">ì§€ëª© ì‹œì‘</button>
        <button class="btn secondary" id="back">ë’¤ë¡œ</button>
      </div>
    `;
    document.getElementById("startVote").onclick=()=>startVoting();
    document.getElementById("back").onclick=()=>setPhase("PLAY_START");
  }

  function renderVoting(){
    const voters=state.voteOrder||[];
    const total=voters.length;

    if(state.voteCursor>=total){
      applyScoring();
      setPhase("RESULT_ROULETTE");
      return;
    }

    const currentVoterId=voters[state.voteCursor];

    // âœ… UIì— ë³´ì´ëŠ” íƒ€ê²Ÿ(íƒ€ì¼) ìˆœì„œëŠ” í•­ìƒ 1..N ê³ ì • (ë‹¨, ìê¸° ìì‹  ì œì™¸)
    const targets = Array.from({length: state.N}, (_,i)=>i+1).filter(id => id !== currentVoterId);

    $app.innerHTML=`
      <div class="card">
        <div class="row">
          <h1>ë¼ì´ì–´ ì§€ëª©</h1>
          <span class="pill">${state.voteCursor+1} / ${total}</span>
        </div>

        <p class="center" style="font-size:22px; font-weight:1000; margin:10px 0 6px;">ì§€ê¸ˆ ì°¨ë¡€: ${pmarkHTML(currentVoterId)}</p>

        ${state.mode==="FULL"
          ? `<p class="center muted">ì•„ë˜ì—ì„œ ë¼ì´ì–´ë¼ê³  ìƒê°í•˜ëŠ” ì‚¬ëŒì„ <b>0.5ì´ˆê°„ ê¾¹</b> ëˆŒëŸ¬ í™•ì •í•˜ì„¸ìš”.</p>
             <div class="tileHoldHint">ì§§ê²Œ íƒ­í•˜ë©´ ì„ íƒë§Œ ë˜ê³ , 0.5ì´ˆ ê¾¹ ëˆŒëŸ¬ì•¼ í™•ì •ë©ë‹ˆë‹¤.</div>`
          : `<p class="center muted">ì•„ë˜ì—ì„œ ë¼ì´ì–´ë¼ê³  ìƒê°í•˜ëŠ” ì‚¬ëŒì„ <b>í„°ì¹˜</b>í•´ì„œ ì„ íƒí•˜ì„¸ìš”.</p>
             <div class="tileHoldHint">ì‹¤ìˆ˜í•˜ë©´ â€œì´ë²ˆ ì°¨ë¡€ ë˜ëŒë¦¬ê¸°â€ë¡œ ë³µêµ¬ ê°€ëŠ¥í•©ë‹ˆë‹¤.</div>`
        }

        <div class="tiles" id="tiles"></div>

        <div class="divider"></div>

        <button class="btn secondary" id="undo">ì´ë²ˆ ì°¨ë¡€ ë˜ëŒë¦¬ê¸°</button>
        <button class="btn secondary" id="cancel">ì·¨ì†Œ(ë¼ìš´ë“œë¡œ)</button>
      </div>
    `;

    const tiles=document.getElementById("tiles");
    tiles.innerHTML=targets.map(tid=>{
      return `
        <div class="tile" data-target="${tid}">
          <div class="tileTitle">${pmarkHTML(tid,true)}</div>
          <div class="tileSub">${tid}ë²ˆ</div>
          ${state.mode==="FULL" ? `<div class="tileHoldBarWrap"><div class="tileHoldBar"></div></div>` : ``}
        </div>
      `;
    }).join("");

    document.querySelectorAll(".tile").forEach(el=>{
      el.setAttribute("draggable","false");
      el.addEventListener("contextmenu",(e)=>e.preventDefault());
      el.addEventListener("selectstart",(e)=>e.preventDefault());
      el.addEventListener("dragstart",(e)=>e.preventDefault());
    });

    document.querySelectorAll(".tile[data-target]").forEach(tile=>{
      const tid=parseInt(tile.getAttribute("data-target"),10);

      if(state.mode==="LITE"){
        tile.addEventListener("click",(e)=>{
          e.preventDefault(); clearTextSelection();
          registerVote(currentVoterId, tid);
          state.voteCursor+=1; save();
          haptic(12);
          render();
        }, {passive:false});
        return;
      }

      const bar=tile.querySelector(".tileHoldBar");
      let holding=false, startedAt=0, raf=null, completed=false;
      const resetBar=()=>{ if(bar) bar.style.width="0%"; };

      const update=()=>{
        if(!holding) return;
        const elapsed=performance.now()-startedAt;
        const p=Math.min(1, elapsed/500);
        if(bar) bar.style.width=(p*100).toFixed(1)+"%";
        if(p>=1 && !completed){
          completed=true; holding=false;
          if(raf) cancelAnimationFrame(raf);

          tile.classList.add("popping");
          haptic(18);

          setTimeout(()=>{
            tile.classList.remove("popping");
            registerVote(currentVoterId, tid);
            state.voteCursor+=1; save();
            render();
          },120);
        }else{
          raf=requestAnimationFrame(update);
        }
      };

      const start=(e)=>{
        if(e.cancelable) e.preventDefault();
        clearTextSelection();
        if(completed) return;

        document.querySelectorAll(".tile.selected").forEach(x=>x.classList.remove("selected"));
        tile.classList.add("selected");

        holding=true; startedAt=performance.now(); completed=false;
        resetBar();
        raf=requestAnimationFrame(update);
      };
      const end=(e)=>{
        if(e.cancelable) e.preventDefault();
        clearTextSelection();
        if(!holding) return;
        holding=false;
        if(raf) cancelAnimationFrame(raf);
        if(!completed) resetBar();
      };

      tile.addEventListener("pointerdown", start, {passive:false});
      tile.addEventListener("pointerup", end, {passive:false});
      tile.addEventListener("pointercancel", end, {passive:false});
      tile.addEventListener("pointerleave", end, {passive:false});
    });

    document.getElementById("undo").onclick=()=>{
      if(state.voteCursor<=0){ toast("ë˜ëŒë¦´ ì°¨ë¡€ê°€ ì—†ì–´ìš”."); return; }
      const prevVoterId=voters[state.voteCursor-1];
      delete state.votes[prevVoterId];
      rebuildAccusations();
      state.voteCursor-=1; save();
      toast("í•œ ì°¨ë¡€ ë˜ëŒë ¸ì–´ìš”.");
      render();
    };

    document.getElementById("cancel").onclick=()=>{
      if(confirm("ì§€ëª©ì„ ì·¨ì†Œí•˜ê³  ë¼ìš´ë“œ í™”ë©´ìœ¼ë¡œ ëŒì•„ê°ˆê¹Œìš”? (ì§€ëª© ì§„í–‰ì€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤)")){
        state.votes={}; state.accusations={}; state.voteOrder=[]; state.voteCursor=0;
        save(); setPhase("ROUND_SETUP");
      }
    };
  }

  function renderResultRoulette(){
    $app.innerHTML=`
      <div class="card">
        <h1 class="center">ë¼ì´ì–´ ê³µê°œ</h1>
        <p class="center muted">ì§œì”â€¦ ë¼ì´ì–´ëŠ” ëˆ„êµ¬ì˜€ì„ê¹Œìš”?</p>

        <div class="rouletteBox" id="rouletteBox">
          <div class="rouletteName" id="rouletteName">â€¦</div>
        </div>

        <div id="afterBox" style="display:none;">
          <div class="divider"></div>
          <h2>ì´ë²ˆ ë¼ìš´ë“œ íšë“ ì ìˆ˜ (Î”)</h2>
          <p class="muted">ì´ì ì€ ê²Œì„ ì¢…ë£Œ ì‹œì—ë§Œ ê³µê°œë©ë‹ˆë‹¤.</p>
          <div class="deltaList" id="deltaList"></div>

          <button class="btn" id="next">ë‹¤ìŒ ë¼ìš´ë“œ</button>
          <button class="btn secondary" id="setup">ë¼ìš´ë“œ ì„¤ì •ìœ¼ë¡œ</button>
          <button class="btn danger" id="end">ê²Œì„ ì¢…ë£Œ (ì ìˆ˜í‘œ ê³µê°œ)</button>
        </div>
      </div>
    `;

    const nameEl=document.getElementById("rouletteName");
    const afterBox=document.getElementById("afterBox");

    if(!state.roulette.running && !state.roulette.done){
      startRoulette();
    }

    const shown = state.roulette.shownName || "â€¦";
    const liarSuccess = (state._lastAccCount || 0) <= 1;

    if(state.roulette.done){
      nameEl.textContent = (liarSuccess ? "ğŸ‘‘ " : "") + shown;
    } else {
      nameEl.textContent = shown;
    }

    if(state.roulette.done){
      afterBox.style.display="block";

      const dl=document.getElementById("deltaList");
      dl.innerHTML = Array.from({length:state.N}, (_,i)=>i+1).map(id=>{
        const d = state.lastRoundDelta?.[id] ?? 0;
        const sign = d>0 ? `+${d}` : `${d}`;
        return `
          <div class="deltaRow">
            <div>${pmarkHTML(id,true)}</div>
            <div class="deltaVal">${sign}</div>
          </div>
        `;
      }).join("");

      document.getElementById("next").onclick=()=>{
        if(maybeEndByRoundLimit()) return;
        nextRound();
      };
      document.getElementById("setup").onclick=()=>setPhase("ROUND_SETUP");
      document.getElementById("end").onclick=()=>{
        if(confirm("ì§€ê¸ˆ ê²Œì„ì„ ì¢…ë£Œí•˜ê³  ì „ì²´ ì ìˆ˜í‘œë¥¼ ê³µê°œí• ê¹Œìš”?")){
          setPhase("GAME_END");
        }
      };
    }
  }

  function renderGameEnd(){
    $app.innerHTML=`
      <div class="card">
        <h1 class="center">ê²Œì„ ì¢…ë£Œ</h1>
        <p class="center muted">ì „ì²´ ì ìˆ˜í‘œ ê³µê°œ!</p>
        <div class="divider"></div>
        ${renderFinalMatrixTable()}
        <button class="btn" id="home">í™ˆìœ¼ë¡œ</button>
        <button class="btn secondary" id="restart">ìƒˆ ê²Œì„ ì‹œì‘(ì´ˆê¸°í™”)</button>
      </div>
    `;
    document.getElementById("home").onclick=()=>setPhase("HOME");
    document.getElementById("restart").onclick=()=>{
      if(confirm("ìƒˆ ê²Œì„ìœ¼ë¡œ ì´ˆê¸°í™”í• ê¹Œìš”?")) resetAll();
    };
  }

  function renderFinalMatrixTable(){
    const rounds = state.roundHistory || [];
    const players = state.players || [];
    const N = state.N || players.length;

    const headerCells = players.map(p => {
      const c = p.color || colorForId(p.id);
      const bg = hexToRgba(c, 0.22);
      return `
        <th style="padding:10px 8px; border-bottom:1px solid #eef0f6; text-align:center;">
          <span class="pmark" style="--c:${c};--bg:${bg}">
            <span class="dot" style="--c:${c}"></span>
            <span>${escapeHtml(p.name)}</span>
          </span>
        </th>
      `;
    }).join("");

    const roundRows = rounds.map(r => {
      const cells = players.map(p => {
        const d = (r.delta && (r.delta[p.id] ?? 0)) ?? 0;
        const sign = d > 0 ? `+${d}` : `${d}`;
        return `<td style="padding:10px 8px; text-align:center; border-bottom:1px solid #f3f4fa; font-weight:900;">${sign}</td>`;
      }).join("");

      return `
        <tr>
          <td style="padding:10px 8px; border-bottom:1px solid #f3f4fa; white-space:nowrap; font-weight:900; color:#444;">
            R${r.round}
          </td>
          ${cells}
        </tr>
      `;
    }).join("");

    const totalCells = players.map(p => {
      return `<td style="padding:12px 8px; text-align:center; font-weight:1000; font-size:16px;">${p.score}</td>`;
    }).join("");

    const emptyState = rounds.length === 0
      ? `<div class="muted" style="text-align:center; padding:14px 0;">ì•„ì§ ì™„ë£Œëœ ë¼ìš´ë“œê°€ ì—†ì–´ìš”.</div>`
      : "";

    return `
      <div class="card" style="box-shadow:none; padding:0; margin:0;">
        <div class="muted" style="margin:0 0 10px;">ë¼ìš´ë“œë³„ íšë“ ì ìˆ˜(Î”)ì™€ ì´ì ì„ í•œ ë²ˆì— í™•ì¸í•  ìˆ˜ ìˆì–´ìš”.</div>

        ${emptyState}

        <div style="overflow:auto; border-radius:14px; border:1px solid #eef0f6; background:#fff;">
          <table style="width:100%; border-collapse:collapse; min-width:${Math.max(520, 130 + N*120)}px;">
            <thead>
              <tr>
                <th style="padding:10px 8px; border-bottom:1px solid #eef0f6; text-align:left; color:#666; font-size:13px;">
                  ë¼ìš´ë“œ
                </th>
                ${headerCells}
              </tr>
            </thead>
            <tbody>
              ${roundRows}
              <tr style="background:#fafbff;">
                <td style="padding:12px 8px; font-weight:1000; border-top:1px solid #eef0f6;">
                  ì´ì 
                </td>
                ${totalCells}
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    `;
  }

  function escapeHtml(str){
    return (str ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");
  }

  render();
})();
</script>
</body>
</html>
